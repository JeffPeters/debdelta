head	1.20;
access;
symbols;
locks; strict;
comment	@# @;


1.20
date	2006.05.30.10.06.52;	author debdev;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.30.08.16.42;	author debdev;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.30.07.51.09;	author debdev;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.30.06.56.38;	author debdev;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.29.14.15.28;	author debdev;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.28.12.41.18;	author debdev;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.27.10.39.53;	author debdev;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.26.16.03.47;	author debdev;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.23.16.18.10;	author debdev;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.23.16.10.55;	author debdev;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.23.13.56.24;	author debdev;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.23.13.27.39;	author debdev;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.23.11.25.10;	author debdev;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.22.14.30.30;	author debdev;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.22.08.35.55;	author debdev;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.20.15.34.38;	author debdev;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.20.11.05.43;	author debdev;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.19.19.36.52;	author debdev;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.19.12.25.14;	author debdev;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.18.19.19.25;	author debdev;	state Exp;
branches;
next	;


desc
@@


1.20
log
@debdelta-upgrade: use a separare thread (and fork :-( ) for the patching.

Again adjustments to VERBOSE... lets say that -vvv is a reasonable output.

debdelta-upgrade: use 'arch' from 'dpkg -p' when creating package file name.
@
text
@#!/usr/bin/python

doc={}
doc['delta']="""\
Usage: debdelta [ option...  ] fromfile tofile patchout
  Computes a delta from fromfile to tofile and writes it to patchout

Options:
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb   maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""


doc['deltas']="""\
Usage: debdeltas [ option...  ] deb_files
  Computes all missing deltas for Debian files deb_files

Options:
--dir DIR   force saving of deltas in this DIR
            (otherwise they go in the dir of the newer deb)
            if DIR ends in // , then the dirname of deb_file
            the  will be used as well
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb     maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""

## implement : --search    search in the directory of the above debs for older versions

doc['patch']="""\
Usage: debpatch [ option...  ] patchin  fromfile  tofile 
  Applies patchin to fromfile and produces a reconstructed  version of tofile.

(When using 'debpatch' and the old .deb is not available,
  use '/' for the fromfile.)

Usage: debpatch --info  patch
  Write info on patch.

Options:
"""

doc['delta-upgrade']="""\
Usage: debdelta-upgrade
  Downloads all deltas that may be used to 'apt-get upgrade', and apply them

Options:
--dir DIR   directory where to save results (default: /tmp/archive)
"""


doc_common="""
  -v      verbose (can be added multiple times)
  -k      keep temporary files
"""

## currently this is always true:
## -d      debug : add md5sums, check that  versions do match

minigzip='/usr/lib/debdelta/minigzip'


####################################################################

import sys , os , tempfile , string ,getopt , tarfile , shutil , time

from stat    import ST_SIZE
from os.path import abspath
from os      import unlink, rmdir
from shutil  import rmtree

################################################# main program, read options


MAXMEMORY = 1024 * 1024 * 50

MAX_DELTA_PERCENT = 50

DEBUG   = 1
VERBOSE = 0
KEEP    = False
INFO    = False
NEEDSOLD= False
DIR     = None

if os.path.dirname(sys.argv[0]) == '/usr/lib/apt/methods' :
  action = None
else:
  action=(os.path.basename(sys.argv[0]))[3:]
  actions =  ('delta','patch','deltas','delta-upgrade')
  
  if action not in actions:
    print 'wrong filename: should be "deb" + '+repr(actions)
    sys.exit(0)

  __doc__ = doc[action] + doc_common

  try: 
      ( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                                     ('help','info','needsold','dir=') )
  except getopt.GetoptError,a:
      sys.stderr.write(sys.argv[0] +': '+ str(a)+'\n')
      sys.exit(2)


  for  o , v  in  opts :
    if o == '-v' : VERBOSE += 1
    elif o == '-d' : DEBUG += 1
    elif o == '-k' : KEEP = True
    elif o == '--needsold' and action == 'delta' :  NEEDSOLD = True
    elif o == '-M' :    MAXMEMORY = 1024 * 1024 * int(v)
    elif o == '--info' and action == 'patch' : INFO = True
    elif o == '--dir'  and action == 'deltas' :
      DIR = v
      if not os.path.isdir(DIR):
        print 'Error: --dir ',DIR,' does not exist.'
        sys.exit(3)
    elif o ==  '--help' or o ==  '-h':
      print __doc__
      sys.exit(0)
    else:
      print ' option ',o,'is unknown, try --help'
      sys.exit(1)



if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a
  def rmtree(a):
    if VERBOSE : print ' would rm -r ',a

#################################################### various routines

def freespace(w):
  try:
    a=os.statvfs(w)
    freespace= a[0] * a[4]
  except:
    if VERBOSE : print ' statvfs error ',a
    freespace=None
  return freespace

dpkg_keeps_controls = (
  'conffiles','config','list','md5sums','postinst',
  'postrm','preinst','prerm','shlibs','templates')

def scan_control(p,params,prefix=None,script=None,stdout = None):
  if prefix == None:
    prefix = ''
  else:
    prefix += '/'
  a=p.readline()
  while a:
    a=de_n(a)
    if a[:4] in ('Pack','Vers','Arch','Stat','Inst','File'):
      if script : script.write('#'+prefix+a+'\n')
      if stdout : stdout.write(' ' + a)
      i=a.index(':')
      assert(a[i:i+2] == ': ')
      params[prefix+a[:i]] = a[i+2:]
    a=p.readline()

def make_parents(f):
  assert(f[0] == '/')
  s=f.split('/')
  d=''
  for a in s[:-1] :
    if a:
      d=d+'/'+a
      if not os.path.exists(d):
        os.mkdir(d)
  d=d+'/'+s[-1]
  return d

#def symlink_w_parents(f,d):
#  d=make_parents(fd)
#  os.symlink(f,d)

def de_n(a):
  if a[-1] ==  '\n' :
    a = a[:-1]
  return a


def list_ar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list

def list_tar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('tar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list


def unpack(d,f,T):
  "unpacks 'ar' file f in directory d"
  assert(os.path.exists(f))
  cwd = os.getcwd()
  os.chdir(T+'/'+d)
  system('ar xo '+f)
  os.chdir(cwd)


ALLOWED = '<>()[]{}.,;:!_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r

from string import join

def version_mangle(v):
  if  ':' in v :
    return join(v.split(':'),'%3a')
  else:
    return v

def tempo():
  TD = abspath(tempfile.mkdtemp())
  for i in 'OLD','NEW','PATCH' :
    os.mkdir(TD+'/'+i)
  if  VERBOSE > 2 or KEEP :  print 'Temporary in '+TD
  return TD

##########


class DebDeltaError:
  def __init__(self,s):
    self.__str = s
  def __str__(self):
    return self.__str

def die(s=None):
  #if s : sys.stderr.write(s+'\n')
  raise DebDeltaError,s

  
def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if ret == 2:
    return KeyboardInterrupt
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    die('Error , non zero return status '+str(ret)+' for command "'+a+'"')

def check_deb(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    die('Error: '+f+ 'does not seem to be a Debian package ')
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    die('Error: '+f+ ' does not seem to be a Debian delta ')
  p.close()

#################################################################### apply patch

def do_patch(delta,olddeb,newdeb,TD):  
  delta=abspath(delta)
  if newdeb:
    newdeb=abspath(newdeb)
  if olddeb != '/':
    olddeb=abspath(olddeb)
    
  start_sec = time.time()
  
  check_diff(delta)

  if INFO:
    os.chdir(TD+'/PATCH')
    system('ar x  '+delta+' patch.sh patch.sh.gz patch.sh.bz2 2> /dev/null')
  else:    
    if olddeb != '/':
      check_deb(olddeb)
    if  newdeb and os.path.exists(newdeb) :
      os.rename(newdeb,newdeb+'~')
    unpack ('PATCH',delta,TD)
  #from here on, we live in the temp dir
  os.chdir(TD)
    
  os.symlink(minigzip,'minigzip')

  if os.path.exists('PATCH/patch.sh.gz'):
    system('gunzip PATCH/patch.sh.gz')
  elif os.path.exists('PATCH/patch.sh.bz2'):
    system('bunzip2 PATCH/patch.sh.bz2')  

  #lets scan parameters, to see what it does and what it requires
  params={}
  if not os.path.isfile('PATCH/patch.sh'):
    die('Error. File '+delta+' is not a debdelta file.')
  p=open('PATCH/patch.sh')
  s=p.readline()#skip #!/bin/sh
  s=p.readline()
  while s :
    if s[0] == '#' :
      s=de_n(s)[1:]
      if VERBOSE > 2 or (VERBOSE and action != 'deltas' and \
                         action != 'delta-upgrade' ) or INFO :
        print ' info: ',s
      if ':' in s:
        i=s.index(':')  
        params[s[:i]] = s[i+2:]
      else:
        params[s] = True
    s=p.readline()
  p.close()

  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      die(' Not enough disk space (%dkB) for applying delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) )

  ## really we will apply the patch
  if not INFO:
    #unpack the old control structure, if available
    os.mkdir(TD+'/OLD/CONTROL')
    if olddeb != '/' :
      os.symlink(olddeb,TD+'/OLD.file')
      #unpack control.tar.gz
      system('ar p OLD.file control.tar.gz | tar -x -z -f - -C OLD/CONTROL')
    #then we check for the conformance
    if  DEBUG:
      dpkg_params={}
      b=params['OLD/Package']
      if olddeb == '/' :
        p=os.popen('env -i dpkg -s '+b)
      else:        
        p=open('OLD/CONTROL/control')
      scan_control(p,dpkg_params,'OLD')
      p.close()
      if  olddeb == '/' :
        if 'OLD/Status' not in dpkg_params:
          die('Error: package %s is not known to dpkg.' % b)
        if  dpkg_params['OLD/Status'] != 'install ok installed' :
          die('Error: package %s is not installed, status is %s.'
            % ( b , dpkg_params['OLD/Status'] ) )
      for a in  params:
        if a[:3] == 'OLD' and a != 'OLD/Installed-Size':
          if a not in dpkg_params:
            die('Error parsing old control file , parameter %s not found' % a)
          elif  params[a] != dpkg_params[a] :
            die( 'Error : in debdelta , '+a+' = ' +params[a] +\
                 '\nin old/installed deb, '+a+' = ' +dpkg_params[a])

    ###see into parameters: the patch may need extra info
    #as a whole unpack of 'ar' of the old deb
    if 'unpack-old' in params:
      if olddeb == '/':
        die('This patch needs the old version Debian package')
      unpack ('OLD',olddeb,TD)

    if 'needs-old' in params and olddeb == '/':
      die('This patch needs the old version Debian package')

    if 'old-data-tree' in params :
      os.mkdir(TD+'/OLD/DATA')
      if olddeb == '/':
        pa=params['OLD/Package']
        s=[]
        p=os.popen('env -i dpkg -L '+pa)
        a=p.readline()
        while a:
          a=de_n(a)
          if s and a[:11] == 'diverted by':
            orig,divert=s.pop()
            #support diversions
            i = a.index(':')
            divert = a[i+2:]
            s.append( (orig,divert) )
          else:
            s.append( (a,a) )
          a=p.readline()
        p.close()        
        for orig,divert in s:          
          if os.path.isfile(divert) and not os.path.islink(divert) :            
            a=make_parents(TD+'/OLD/DATA'+orig)
            if VERBOSE > 3 : print '   symlinking ',divert,' to ',a
            os.symlink(divert, a)
          else:
            if VERBOSE > 4 : print '    not symlinking ',divert,' to ',orig
      else:
        system('ar p OLD.file data.tar.gz | tar -x -z -f - -C OLD/DATA')


    if 'old-control-tree' in params and olddeb == '/':      
      p=params['OLD/Package']
      for  b in dpkg_keeps_controls :
        a='/var/lib/dpkg/info/' + p +'.'+b
        if os.path.exists(a ):
          os.symlink(a,'OLD/CONTROL/'+b)

    ##then , really execute the patch
    a=''
    if VERBOSE >= 4 : a = '-v'
    system('/bin/sh -e '+a+' PATCH/patch.sh')
    if newdeb:
      shutil.move('NEW.file',newdeb)

    if VERBOSE :
      if newdeb:
        debsize = os.stat(newdeb)[ST_SIZE]
      else:
        debsize = os.stat(olddeb)[ST_SIZE]
      end_sec = time.time()
      a=(end_sec - start_sec)
      print ' patching time: %dsec, speed:  %dkB per second ' % (a,(debsize / 1024 /  (a+1)))

##################################################### compute delta

def do_delta(olddeb,newdeb,delta,TD):
  start_sec = time.time()

  olddeb=abspath(olddeb)
  check_deb(olddeb)
  os.symlink(olddeb,TD+'/OLD.file')

  newdeb=abspath(newdeb)
  check_deb(newdeb)
  os.symlink(newdeb,TD+'/NEW.file')
  newdebsize = os.stat(newdeb)[ST_SIZE]

  free=freespace(TD)
  if free and free < newdebsize * 2:
    die('Error: not enough disk space in '+TD)

  delta=abspath(delta)
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  #from here on, we live in the temp dir
  os.chdir(TD)

  #counter for numbered files
  global deltacount
  deltacount = 0 

  #start writing script 
  script=open('PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')


  def append(s):
    'appends some data to NEW.file'
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")

  ##### unpack control.tar.gz, scan control, write  parameters
  params={}
  for o in 'OLD', 'NEW' :
      os.mkdir(TD+'/'+o+'/CONTROL')
      #unpack control.tar.gz
      system('ar p '+o+'.file control.tar.gz | tar -x -z -f - -C '+o+'/CONTROL')
      ## scan control
      if  VERBOSE > 1 :
        print o
        s=sys.stdout
      else:
        s=None
      p=open(TD+'/'+o+'/CONTROL/control') 
      scan_control(p,params,o,script,s)
      p.close()
      if s: print
  
  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)  
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      die(' Not enough disk space (%dkB) for creating delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) )

  ## check for conffiles 
  a=TD+'/OLD/CONTROL/conffiles'
  if os.path.exists(a):
    p=open(a)
    old_conffiles=p.read().split('\n')
    p.close()
  else:
    old_conffiles=()
  ############### some routines  to prepare delta of two files

  def patch_append(f):
    os.chdir(TD+'/PATCH')
    system(['ar','qSc', delta,f])
    unlink(f)
    os.chdir(TD)

  def verbatim(f):
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    if VERBOSE > 3 : print '   including "',name,'" verbatim in patch'
    os.rename(f,p)
    patch_append(pp)
    return p
      
  def unzip(f, in_script_as_well = None):
    c=''
    if f[-3:] == '.gz' :
      system('gunzip '+f)
      if in_script_as_well or ( in_script_as_well == None and f[:3] != 'NEW' ):
        script.write('gunzip '+f+'\n')
      f=f[:-3]
      c='.gz'
    elif  f[-3:] == '.bz2' :
      print 'WARNING ! ',f,' is in BZIP2 format ! please fixme !'
    return (f,c)

  def script_zip(n,cn):
    if cn == '.gz' :
      script.write('./minigzip -9 '+n+'\n')
    elif  cn == '.bz2' :
      print 'WARNING ! ',n,' is in BZIP2 format ! please fixme !'
      
  def delta_files(o,n):
    " compute delta of two files , and prepare the script consequently"
    if VERBOSE > 3 : print '   compute delta for  ',o,' and ',n
    nsize = os.stat(n)[ST_SIZE]
    osize = os.stat(o)[ST_SIZE]
    (o,co) = unzip(o)
    (n,cn) = unzip(n)
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    ## according to the man page,
    ## bsdiff uses memory equal to 17 times the size of oldfile
    ## but , in my experiments, this number is more like 12
    free=freespace(TD)
    if free == None :
      free = MAXMEMORY * 16
    if ( osize < (MAXMEMORY / 12)) and (osize < (free / 8)) :
      system('bsdiff  '+o+' '+n+' '+p)
      script.write('bspatch '+o+' '+n+' '+p+'\n')
    else:
      if VERBOSE > 3 : print '   fallback on xdelta instead of bsdiff' 
      system('xdelta delta -n -9 '+o+' '+n+' '+p)
      script.write('xdelta patch '+p+' '+o+' '+n+'\n')
    ## clean up
    script.write('rm '+p+' '+o+'\n')
    script_zip(n,cn)
    ## how did we fare ?
    deltasize = os.stat(p)[ST_SIZE]
    if VERBOSE > 2 :
      print '  delta is  %3.4f'  % ( deltasize * 100. /  nsize ) , '% of ',n
    #save it
    patch_append(pp)
    #clean up
    unlink(o)
    unlink(n)
    if DEBUG:
      pass #implement MD5

  def delta_tar(o,n,w,skip=()):
    (o,co) = unzip(o,False)
    (n,cn) = unzip(n)
    oldtar = tarfile.open(o, "r")
    oldnames = oldtar.getnames()
    if VERBOSE > 3 : print '   scanning ',n
    newtar = tarfile.open(n, "r")
    for newtarinfo in newtar:
      name = newtarinfo.name
      if  (('/'+name) in  skip ) or ( name in skip ):
        if VERBOSE > 3 : print '   skip using old file ', name
      elif name in oldnames and  newtarinfo.isreg() :
        oldtarinfo = oldtar.getmember(newtarinfo.name)
        if oldtarinfo.isreg() :
          if VERBOSE > 4 : print '  use old file ', name
          oldtar.extract(oldtarinfo.name,"OLD/"+w )
          system("cat 'OLD/"+w+"/"+name+"' >> OLD/mega_cat")
          unlink('OLD/'+w+'/'+name)
          script.write("cat 'OLD/"+w+"/"+name+"'  >> OLD/mega_cat ; rm 'OLD/"+w+"/"+name+"'\n")
      elif VERBOSE > 4 : print '  not diffable from old : ', name

    if os.path.exists('OLD/mega_cat'):
      rmtree('OLD/'+w)
      delta_files('OLD/mega_cat',n)
    else:
      p=verbatim(n)
      script.write('mv '+p+' '+n+ '\n')
    unlink(o)
    script_zip(n,cn)
  ############ start computing deltas

    
  if NEEDSOLD :
    #this delta needs the old deb 
    script.write('#needs-old\n')

  #this following is actually
  #def delta_debs_using_old(old,new):

  ### start scanning the new deb  
  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append(s)

  #process all contents of old vs new .deb
  ar_list_old= list_ar('OLD.file')
  ar_list_new= list_ar('NEW.file')

  for name in ar_list_new :
    n = 'NEW/'+name
    system('ar p NEW.file '+name+' >> '+n)

    newsize = os.stat(n)[ST_SIZE]
    if VERBOSE > 2: print ' studying ' , name , ' of len ' , newsize
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 4: print '  ar line: ',repr(s)
    assert( s[:len(name)] == name and s[-2] == '`' and s[-1] == '\n' )
    append(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(newsize  ,1)
    if newsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if newsize < 128:      #file is too short to compute a delta,
      p=open(n)
      append( p.read(newsize))
      p.close()
      unlink(n)
    elif  name[:11] == 'control.tar' :
      #(mm this is almost useless, just saves a few bytes)
      script.write('#old-control-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      ##avoid using strange files that dpkg may not install in /var...info/
      skip=[]
      for a in os.listdir('OLD/CONTROL') :
        if a not in dpkg_keeps_controls:
          skip.append(a)
      #delta it
      delta_tar(o,n,'CONTROL',skip)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif not NEEDSOLD and name[:8] == 'data.tar'  :
      script.write('#old-data-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      delta_tar(o,n,'DATA',old_conffiles)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif  not NEEDSOLD  or name not in ar_list_old :   #or it is not in old deb
      p=verbatim(n)
      script.write('cat '+p+' >> NEW.file ; rm '+p+'\n')
    elif  NEEDSOLD :
      #file is long, and has old version ; lets compute a delta
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      script.write('ar p OLD.file '+name+' >> '+o+'\n')
      delta_files(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    else:
      die('internal error')
    #pad new deb
    if extrachar :
      append(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if s:
    if VERBOSE > 2: print '  ar leftover character: ',repr(s)
    append(s)

  if DEBUG:
    # add a MD5 check to script
    p=os.popen('md5sum NEW.file')
    a=p.readline()
    p.read()
    p.close
    a=de_n(a)
    if VERBOSE > 2 : print '   ',a
    script.write('echo "'+a+'" | md5sum -c > /dev/null')

  #script is done
  script.close()
  patchsize = os.stat('PATCH/patch.sh')[ST_SIZE]
  if  patchsize > newdebsize / 5 and patchsize > 512 :
    if VERBOSE > 2 : print '  patch.sh is quite large: using bzip2 '
    system('bzip2 -9  PATCH/patch.sh')
    patch_append('patch.sh.bz2')
  else:
    system('gzip -9 -n PATCH/patch.sh')  
    patch_append('patch.sh.gz')

  deltasize = os.stat(delta)[ST_SIZE]
  
  elaps =  time.time() - start_sec
  percent =  deltasize * 100. /  newdebsize 
  if VERBOSE:
    print ' deb delta is  %3.1f%% of deb ; that is, %dkB would be saved' \
          % ( percent , (( newdebsize -deltasize ) / 1024) )
    if VERBOSE :
      print '  delta time: %dsec, speed: %dkB per second ' %  \
            (elaps, newdebsize / 1024 / (elaps+1))
  return (delta, percent, elaps)


##################################################### compute many deltas

def do_deltas(argv):
  original_cwd = os.getcwd()
  try:
    from apt import VersionCompare
  except ImportError:
    import apt_pkg
    apt_pkg.InitSystem()
    from apt_pkg import VersionCompare
  debs=[]
  for i in argv:
    debs.append(i)

  info_by_pack_arch={}
  info_by_file={}

  def scan_deb(f):
      info_by_file[f]={}
      p=os.popen('ar p '+f+' control.tar.gz | tar -x -z -f - -O ./control')
      scan_control(p,info_by_file[f])
      p.close()
      info_by_file[f]['File'] = f
      pa=info_by_file[f]['Package']
      ar=info_by_file[f]['Architecture']
      if  (pa,ar) not in  info_by_pack_arch :
         info_by_pack_arch[ (pa,ar) ]=[]
      info_by_pack_arch[ (pa,ar) ].append( info_by_file[f] )

  for f in debs:
    if os.path.isfile(f):
      scan_deb(f)
    elif  os.path.isdir(f) :
      for a in  filter( lambda a : a[-4:] == '.deb' ,os.listdir(f) ) :
        scan_deb(f+'/'+a)
    else:
      print 'Warning: '+f+' is not a regular file or a directory.'
      
  def order_by_version(a,b):
    return VersionCompare( a['Version'] , b['Version']  )
  
  for pa,ar in info_by_pack_arch :
    l= len( info_by_pack_arch[ (pa,ar) ] )

    if l > 1 :
      info_by_pack_arch[ (pa,ar) ].sort(order_by_version)

      l -= 1
      while l>0:
        os.chdir(original_cwd)
        l -= 1
        old=info_by_pack_arch[ (pa,ar) ][l]
        new=info_by_pack_arch[ (pa,ar) ][l+1]

        newdebsize=os.stat(new['File'])[ST_SIZE]
        #very small packages cannot be effectively delta-ed
        if newdebsize <= 4 * 1024 :
          #this actually affects 1 every 60 packages in the archives
          if VERBOSE > 1:     print 'Skip , too small: ', new['File']
          break
        
        assert( old['Package'] == pa and pa == new['Package'] )
        deltabasename = pa +'_'+  version_mangle(old['Version']) +\
                        '_'+ version_mangle(new['Version']) +'_'+ar+'.debdelta'
        if DIR:
          if DIR[-2:] == '//' :
            a=DIR+'/'+os.path.dirname(new['File'])+'/'+deltabasename
            delta=make_parents(a)
          else:
            delta = DIR+'/'+deltabasename
        else:
          delta = os.path.dirname(new['File']) + '/'+deltabasename
        if os.path.exists(delta):
          if VERBOSE > 2:     print 'Skip , already exists: ',delta
          break
        if os.path.exists(delta+'-too-big'):
          if VERBOSE > 2:     print 'Skip , tried and too big: ',delta
          break

        free=freespace(os.path.dirname(delta))
        if free and free < newdebsize /2 + 1024 :
          if VERBOSE : print 'Not enough disk space for storing ',delta
          break
        
        if VERBOSE: print 'Creating :',delta
        ret= None
        T=tempo()          
        try:
          ret=do_delta(old['File'],new['File'], delta,T)
        except KeyboardInterrupt:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          rmtree(T)
          raise
        except DebDeltaError,s:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          if not VERBOSE: print 'Creating: ',delta
          print ' Creation of delta failed, reason: ',str(s)
        except:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          raise
        os.chdir(original_cwd)
        rmtree(T)

        if ret and MAX_DELTA_PERCENT:
          if ret[1] > MAX_DELTA_PERCENT and os.stat(delta)[ST_SIZE] >= 4*1024 :
            os.unlink(delta)
            if VERBOSE : print ' Warning, too big!'
            p=open(delta+'-too-big','w')
            p.close()
            ret = None

        if DEBUG > 1 and ret :
          T=tempo()
          try:
            do_patch(delta,old['File'],None ,T)
          except KeyboardInterrupt:
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
            rmtree(T)
            raise
          except DebDeltaError,s:
            print ' Error: testing of delta failed: ',str(s)
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
          except:
            print " Unexpected error while testing delta:", sys.exc_info()[0]
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
            rmtree(T)
            raise
          os.chdir(original_cwd)
          rmtree(T)

################################################# main program, do stuff

if action == 'patch':
  if INFO  :
    if  len(argv) > 1 and VERBOSE :
      print '(printing info - extra arguments are ignored)'
    elif  len(argv) == 0  :
      print ' need a  filename ;  try --help'
      sys.exit(1)
  elif len(argv) != 3 :  
    print ' need 3 filenames ;  try --help'
    sys.exit(1)
  
  newdeb=abspath(argv[2])
  T=tempo()
  try:
    do_patch(abspath(argv[0]), abspath(argv[1]), newdeb ,T)
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    rmtree(T)
    sys.exit(2)
  except KeyboardInterrupt:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
  except:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    raise
  rmtree(T)
  
elif action == 'delta' :
  if len(argv) != 3 :  
    print ' need 3 filenames ;  try --help'
    sys.exit(1)
    
  T=tempo()
  delta=abspath(argv[2])
  try:
    do_delta(abspath(argv[0]), abspath(argv[1]), delta ,T)  
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    rmtree(T)
    if os.path.exists(delta):
      os.unlink(delta)
    sys.exit(2)
  except KeyboardInterrupt:
    if os.path.exists(delta):
      os.unlink(delta)
  except:
    if os.path.exists(delta):
      os.unlink(delta)
    raise
  rmtree(T)
  
elif action == 'deltas' :
  try:
    do_deltas(argv)
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    sys.exit(2)

##################################################### delta-upgrade
    
elif action == 'delta-upgrade' :
  import  thread , pickle

  original_cwd = os.getcwd() 
  import httplib
  conn=httplib.HTTPConnection("tonelli.sns.it")
  delta_http_base='/mirror/debian-deltas'

  import  apt, apt_pkg
  apt_pkg.init()

  cache=apt.Cache()
  cache.upgrade()

  if DIR == None:
    DIR='/tmp/archives'
  if not os.path.exists(DIR):    
    os.mkdir(DIR)

  print 'Recreated debs are saved in ',DIR
  start_sec = time.time()
  len_newdebs=0

  (qout,qin)=os.pipe()
  #qoutf=os.fdopen(qout)
  def thread_do_patch(qout,qin):
      if VERBOSE>=2 : print ' Patching thread started. '
      while 1:
        s=os.read(qout,1)
        c=''
        while s != '\t' :
          c+=s
          s=os.read(qout,1)
        if c == '\t' or c == '': break
        (name,tmp_delta , newdeb) = pickle.loads(c)      
        if VERBOSE>=2 : print ' Now patching for: ',name
        # my fault... echo do_patch() wants its own CWD!
        pid=os.fork()
        if pid == 0:
          T=tempo()
          try:
            ret=do_patch(tmp_delta,'/',newdeb ,T)
            if VERBOSE : print '   for ',name
          except DebDeltaError,s:
            print ' Error: applying of delta for ',name,'failed: ',str(s)
            if os.path.exists(newdeb):
              os.unlink(newdeb)
          except:
            print " Error while applying delta for ",name,":",sys.exc_info()
            if os.path.exists(newdeb):
              os.unlink(newdeb)
          if os.path.exists(tmp_delta):
            unlink(tmp_delta)
          os.chdir(original_cwd)
          if os.path.exists(T):
            rmtree(T)
        else:
          os.waitpid(pid,0)
        global len_newdebs
        if len_newdebs != None and os.path.exists(newdeb):
          len_newdebs += os.stat(newdeb)[ST_SIZE]
      if VERBOSE>=2 : print ' Patching thread loop ended. '
      s=os.write(qin,'\t')
      s=os.read(qout,2)
      if VERBOSE>=2 : print ' Patching thread ended , bye bye. '
      return

  thread_patch=thread.start_new_thread(thread_do_patch  ,(qout,qin))

  for p in cache :
    if p.isInstalled and  p.markedUpgrade \
           and p.candidateOrigin[0].origin == 'Debian':

      ## FIXME : how do I get the URI and/or architecture out of python-apt ??
      #if p.sourcePackageName[:3] == 'lib':
      #  b=p.sourcePackageName[:4]
      #else:
      #  b=p.sourcePackageName[0]
      #c=p.candidateOrigin[0].component
      ## rely on usual pool structure....
      #u=c+'/'+b+'/'+p.sourcePackageName
      ##this sucks... it is so slow..., but it works
      dpkg_params={}
      pip=os.popen('env -i dpkg -p '+p.name)
      scan_control(pip,dpkg_params)
      pip.close()
      arch=dpkg_params['Architecture']
      deb_uri=dpkg_params['Filename']
      assert(dpkg_params['Version'] == p.installedVersion )


      newdeb=p.name+'_'+version_mangle(p.candidateVersion)+'_'+arch+'.deb'
      if os.path.exists(DIR+'/'+newdeb) or \
             os.path.exists('/var/cache/apt/archives/'+newdeb):
        if VERBOSE: print  'Already downloaded: ',newdeb
        continue

      if VERBOSE:
        print 'Looking for a delta for %s from %s to %s ' % \
              ( p.name, p.installedVersion, p.candidateVersion )

      newdeb = DIR+'/'+newdeb

      #delta name
      delta_name=p.name+'_'+version_mangle(p.installedVersion)+\
                  '_'+ version_mangle(p.candidateVersion)+'_'+\
                  arch+'.debdelta'

      uri=delta_http_base+'/'+os.path.dirname(deb_uri)+'/'+delta_name

      if VERBOSE > 2: print ' uri ',uri

      conn.connect()
      conn.request("GET", uri)
      r = conn.getresponse()
      if r.status != 200:
        if VERBOSE: print '  delta is not available',repr(r.status), r.reason
        data1 = r.read()
        continue
      (delta_fd, tmp_delta) = tempfile.mkstemp()
      j=0
      s=r.read(1024)
      while s:
        os.write(delta_fd,s)
        j += 1
        sys.stderr.write(" %5d kB for %s \r" % ( j , delta_name))
        s=r.read(1024)        
      os.close(delta_fd)
      conn.close()
      sys.stderr.write(" " * 70 + '\r')

      #append to queue
      c=pickle.dumps(  (p.name,tmp_delta,newdeb) )
      os.write(qin, c + '\t' )

  #terminate queue
  os.write(qin,'\t\t\t')
  if VERBOSE>=2 : print ' Downloading done, waiting for patching thread. '
  os.read(qout,1)
  #while thread_patch:    time.sleep(1)

  elaps =  time.time() - start_sec
  if VERBOSE:
    print 'Delta-upgrade download and patch time: %dsec; virtual speed: %dkB per second.' %  \
          (elaps, len_newdebs / 1024 / (elaps+1)) 
##################################################### apt method
### still work in progress
      
elif  os.path.dirname(sys.argv[0]) == '/usr/lib/apt/methods' :
  import os,sys, select, fcntl, apt, thread, threading, time

  apt_cache=apt.Cache()
  
  log=open('/tmp/log','a')
  log.write('  --- here we go\n')
  
  ( hi, ho , he) = os.popen3('/usr/lib/apt/methods/http.distrib','b',2)

  nthreads=3

  class cheat_apt_gen:
    def __init__(self):
      self.uri=None
      self.filename=None
      self.acquire=False
    def process(self,cmd):
      if self.uri:
        self.filename=cmd[10:-1]
        log.write(' download %s for %s\n' % (repr(self.uri),repr(self.filename)))
        self.uri=None
        self.filename=None
        self.acquire=False
        return cmd
      elif self.acquire:
        self.uri=cmd[5:-1]
        return cmd
      elif cmd[:3] == '600' :
        self.acquire=True
      else:
        return cmd
  
  def copyin():
    bufin=''
    while 1:
      #print ' o'
      s=os.read(ho.fileno(),1)
      bufin += s
      if log and bufin and (s == '' or s == '\n') :
        log.write( ' meth ' +repr(bufin)+'\n' )
        bufin=''
      if s == '':
        thread.interrupt_main(   )
        global nthreads
        if nthreads:
          nthreads-=1
        #log.write( ' in closed \n' )
        #return
      os.write(1,s)


  def copyerr():
    buferr=''
    while 1:
      s=os.read(he.fileno(),1)
      buferr += s
      if log and buferr and (s == '' or s == '\n') :
        log.write( ' err ' +repr(buferr)+'\n' )
        buferr=''
      if s == '':
        thread.interrupt_main(   )
        global nthreads
        if nthreads:
          nthreads-=1
        log.write( ' err closed \n' )
        #return
      os.write(2,s)

  def copyout():
    gen=cheat_apt_gen()
    bufout=''
    while 1:
      s=os.read(0,1)
      bufout += s
      if log and bufout and (s == '' or s == '\n') :
        log.write( ' apt ' +repr(bufout)+'\n' )

        bufout=gen.process(bufout) 
        
        bufout=''
      if s == '':
        thread.interrupt_main()
        global nthreads
        if nthreads:
          nthreads-=1
        #log.write( ' out closed \n' )
        #return
      os.write(hi.fileno(),(s))

        
  tin=thread.start_new_thread(copyin,())
  tout=thread.start_new_thread(copyout,())
  terr=thread.start_new_thread(copyerr,())
  while nthreads>0 :
    log.write( ' nthreads %d \n' % nthreads )
    try:
      while nthreads>0 :
        time.sleep(1)      
    except KeyboardInterrupt:
      pass
  sys.exit(0)

@


1.19
log
@Allow -M in debdeltas.

Bug: do not remove non-existent file.
@
text
@d429 1
a429 1
    if VERBOSE > 2 : a = '-v'
d944 1
a945 4
  p=os.popen('dpkg --print-architecture')
  arch=de_n(p.read())
  p.close()
  
d950 1
a950 1
  
d966 46
a1015 12
      newdeb=p.name+'_'+version_mangle(p.candidateVersion)+'_'+arch+'.deb'
      if os.path.exists(DIR+'/'+newdeb) or \
             os.path.exists('/var/cache/apt/archives/'+newdeb):
        if VERBOSE: print  'Already downloaded: ',newdeb
        continue

      if VERBOSE:
        print 'Looking for a delta for %s from %s to %s ' % \
              ( p.name, p.installedVersion, p.candidateVersion )

      newdeb = DIR+'/'+newdeb

d1029 2
a1030 2
      a=dpkg_params['Architecture']
      u=dpkg_params['Filename']
d1032 14
d1049 1
a1049 1
                  a+'.debdelta'
d1051 1
a1051 1
      uri=delta_http_base+'/'+os.path.dirname(u)+'/'+delta_name
d1073 11
a1083 11
      T=tempo()
      try:
        ret=do_patch(tmp_delta,'/',newdeb ,T)
        len_newdebs += os.stat(newdeb)[ST_SIZE]
      except DebDeltaError,s:
        print ' Error: applying of delta failed: ',str(s)
        if os.path.exists(newdeb):
          os.unlink(newdeb)
      unlink(tmp_delta)
      os.chdir(original_cwd)
      rmtree(T)
d1087 1
a1087 1
          (elaps, len_newdebs / 1024 / (elaps+1))
@


1.18
log
@On keyboard interrupt, clean up tmp files.

The test for xdelta VS bsdiff was not working (wrong parentheses?).
Moreover, my test shows that bsdiff uses 12 times the memory not 17.

Quote filenames in patch.sh.
@
text
@d110 1
a110 1
    elif o == '-M' and action == 'delta' :    MAXMEMORY = 1024 * 1024 * int(v)
d330 3
a332 1
      if VERBOSE > 1 or (VERBOSE and action != 'deltas' ) or INFO : print ' info: ',s
d1034 2
a1035 1
        os.unlink(newdeb)
@


1.17
log
@Recover upstream uri and architecture from 'dpkg -p' (very slow but it
works).

Adjustments to verbosity.

die() does not print anything; DebDeltaError ships the error message.
@
text
@d559 1
d561 1
d565 1
a565 1
    if osize < MAXMEMORY / 17 and osize * 8 < free  :
d569 1
a569 1
      if VERBOSE > 4 : print '  fallback on xdelta instead of bsdiff' 
d603 1
a603 1
          system('cat OLD/'+w+'/'+name+' >> OLD/mega_cat')
d605 1
a605 1
          script.write('cat OLD/'+w+'/'+name+'  >> OLD/mega_cat ; rm OLD/'+w+'/'+name+'\n')
d792 1
a792 1
          if VERBOSE :     print 'Skip , too small: ', new['File']
d824 4
d856 4
d867 1
d869 3
a871 2
            print " Unexpected error while testing delta:", sys.exc_info()[0]
            os.unlink(delta)
d899 3
d923 3
@


1.16
log
@Implements 'debdelta-upgrade' .

Start writing some kind of APT method

Change ':' to '%3a' in file names.
@
text
@d157 1
a157 1
    if a[:4] in ('Pack','Vers','Arch','Stat','Inst'):
d255 2
a256 2
  def __str__(self,s):
    return __str
d259 1
a259 1
  if s : sys.stderr.write(s+'\n')
d330 1
a330 1
      if VERBOSE or INFO : print ' info: ',s
d432 1
a432 1
    if VERBOSE > 1:
d726 1
a726 1
    if VERBOSE > 1:
d813 1
a813 1
          if VERBOSE : print ' Not enough disk space for',delta
d823 1
a823 1
        except DebDeltaError:
d827 2
a828 1
          print ' Creation of ',delta,' failed.'
d838 1
a838 1
          if ret[1] > MAX_DELTA_PERCENT:
d840 1
a840 1
            if VERBOSE : print ' Error, too big!'
d851 2
a852 2
          except DebDeltaError:
            print ' Error: testing of delta failed: ',delta
d881 2
a882 1
  except DebDeltaError:
d902 2
a903 1
  except DebDeltaError:
d917 2
a918 1
  except DebDeltaError:
d932 1
a932 1
  delta_http_base='/mirror/debian-deltas/pool/'
d946 3
a948 1
  
d964 17
a980 1
      
d983 5
a987 9
                  '_'+ version_mangle(p.candidateVersion)+'_i386.debdelta'
      ## FIXME : how do I get the URI out of python-apt ??
      if p.sourcePackageName[:3] == 'lib':
        b=p.sourcePackageName[:4]
      else:
        b=p.sourcePackageName[0]
      c=p.candidateOrigin[0].component
      ## rely on usual pool structure....
      uri=delta_http_base+c+'/'+b+'/'+p.sourcePackageName +'/'+delta_name
d1011 3
a1013 2
      except DebDeltaError:
        print ' Error: applying of delta failed: ',delta
d1018 4
a1021 2

  
@


1.15
log
@Catch getopt exception.

1/60th of packages is of size less than 4kB ; and those produce "large" deltas.
@
text
@d15 2
a16 2
Usage: debdeltas [ option...  ] debs
  Computes all missing deltas for debs
d21 2
a22 2
            if DIR ends in // , then the dirname of the arguments will be used as well
--search    search in the directory of the above debs for older versions
d27 2
d42 9
a73 16

action=(os.path.basename(sys.argv[0]))[3:]
actions =  ('delta','patch','deltas')
if action not in actions:
  print 'wrong filename: should be "deb" + '+repr(actions)
  sys.exit(0)

__doc__ = doc[action] + doc_common

try: 
  ( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                                 ('help','info','needsold','dir=') )
except getopt.GetoptError,a:
  sys.stderr.write(sys.argv[0] +': '+ str(a)+'\n')
  sys.exit(2)

d85 8
a92 14
for  o , v  in  opts :
  if o == '-v' : VERBOSE += 1
  elif o == '-d' : DEBUG += 1
  elif o == '-k' : KEEP = True
  elif o == '--needsold' and action == 'delta' :  NEEDSOLD = True
  elif o == '-M' and action == 'delta' :    MAXMEMORY = 1024 * 1024 * int(v)
  elif o == '--info' and action == 'patch' : INFO = True
  elif o == '--dir'  and action == 'deltas' :
    DIR = v
    if not os.path.isdir(DIR):
      print 'Error: --dir ',DIR,' does not exist.'
      sys.exit(3)
  elif o ==  '--help' or o ==  '-h':
    print __doc__
a93 3
  else:
    print ' option ',o,'is unknown, try --help'
    sys.exit(1)
d95 29
a123 9
if INFO  :
  if  len(argv) > 1 and VERBOSE :
    print '(printing info - extra arguments are ignored)'
  elif  len(argv) == 0  :
    print ' need a  filename ;  try --help'
    sys.exit(1)
elif action != 'deltas' and len(argv) != 3 :  
  print ' need 3 filenames ;  try --help'
  sys.exit(1)
d234 1
d236 5
d794 2
a795 1
        deltabasename = pa +'_'+  old['Version'] +'_'+ new['Version'] +'_'+ar+'.debdelta'
d839 1
a839 1
            if VERBOSE : print ' Error, too big:',delta
d866 10
d891 5
a895 1
elif action == 'delta' :  
d917 89
d1007 99
a1105 1
    
@


1.14
log
@Corrected some bugs.

Some checks for disk space.
@
text
@d72 6
a77 4
( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                               ('help','info','needsold','dir=') )


d775 3
a777 1
        if newdebsize <= 20 * 1024 :
@


1.13
log
@'debdeltas' to scan archive and create many deltas

'debdelta' deals with dpkg diversions

main operations are now functions

errors are reported using exceptions

reviewed verbosity
@
text
@d78 2
a79 1
MAX_DELTA_PERCENT = 40
d95 5
a99 1
  elif o == '--dir'    and action == 'deltas' : DIR = v
a125 2


d149 1
a149 1
    if a[:3] in ('Pac','Ver','Arc','Sta'):
d160 1
a160 1
  d='/'
a237 1

d239 4
a242 1
  pass
d325 6
d357 1
a357 1
        if a[:3] == 'OLD':
d382 1
d388 1
a388 1
            s.append(orig,divert)
d393 2
a394 2
        for orig,divert in s:
          if os.path.isfile(divert) and not os.path.islink(divert) :
d396 1
d398 2
d482 7
d740 1
a740 1
      info_by_file[f]['File'] = abspath(f)
d772 3
a774 3

        if os.stat(new['File'])[ST_SIZE] < 16 * 1024 :
          if VERBOSE > 2:     print 'Skip , too small: ', new['File']
d781 2
a782 2
            a=os.path.dirname(new['File'])+'/'+deltabasename
            delta=make_parents(a,DIR)
a793 1

d795 1
a795 1
        if free and free < 2 ** 20 :
d804 3
d808 3
a810 3
        except DebDeltaError:
          os.unlink(delta)
          print 'Creation of ',delta,' failed.'
d812 3
a814 1
          os.unlink(delta)
d816 2
a817 1
          rmtree(T)
d822 1
a822 1
            if VERBOSE : print 'Error, too big:',delta
d831 4
d836 2
d839 2
a840 2
            print "Unexpected error:", sys.exc_info()[0]
            print 'Error: applying of delta failed: ',delta
d843 1
a844 1
        
a845 2

  
d854 2
a855 1
    os.unlink(newdeb)
d859 2
a860 1
    os.unlink(newdeb)
d871 2
a872 1
    os.unlink(delta)
d875 2
a876 1
    os.unlink(delta)
@


1.12
log
@Typo.
@
text
@d3 2
a4 1
"""\
d8 20
d29 1
a29 1
  Applies patchin to fromfile and produces  a  reconstructed  version of tofile.
d37 2
a38 6
Options for debdelta:
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb   maximum memory (to decide if using 'bsdiff' or 'xdelta')

Options for debpatch:
 --info  print info on two Debian files, and exists
d40 1
a40 1
Options for both:
d60 1
a60 1
####################################################################
a61 1
start_sec = time.time()
d65 1
a65 1
actions =  ('delta','patch')
d70 2
d73 2
a74 1
                               ('help','info','needsold') )
a75 1
original_cwd = os.getcwd()
d78 2
d85 1
d94 1
d108 1
a108 1
elif len(argv) != 3  or ( len(argv) != 3   ):  
d112 21
a132 1
######################################################################
d138 5
a142 1
def scan_control(p,params,prefix,script=None,stdout = None):
d146 2
a147 2
    if a[:3] in ('Pac','Ver','Arc'):
      if script : script.write('#'+prefix+'/'+a+'\n')
d151 1
a151 1
      params[prefix+'/'+a[:i]] = a[i+2:]
d154 4
a157 2
def symlink_w_parents(f,d):
  s=f.split('/') 
d160 1
a160 1
      d = d + '/' + a
d162 7
a168 4
        os.mkdir(d)      
  d += '/'+s[-1]
  os.symlink(f,d)

d201 1
a201 1
def unpack(d,f):
d205 1
a205 1
  os.chdir(TD+'/'+d)
a222 8
####################################################################
if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a
  def rmtree(a):
    if VERBOSE : print ' would rm -r ',a
a223 4
TD = abspath(tempfile.mkdtemp())
for i in 'OLD','NEW','PATCH' :
  os.mkdir(TD+'/'+i)
if  VERBOSE > 1 or KEEP :  print 'temporary in '+TD
d225 6
d234 5
d241 1
a241 2
  rmtree(TD)
  sys.exit(2)
d248 2
d271 9
a279 2
if action == 'patch':  
  delta = abspath(argv[0])
a285 1
    olddeb = abspath(argv[1])
d288 1
a288 3

    newdeb = abspath(argv[2])
    if  os.path.exists(newdeb) :
d290 1
a290 2
    
    unpack ('PATCH',delta)
d334 1
a334 1
        p=os.popen('dpkg -s '+b)
d339 6
d358 1
a358 1
      unpack ('OLD',olddeb)
d364 1
d366 19
a384 11
        a=params['OLD/Package']
        b='/var/lib/dpkg/info/' + a +'.list'
        if not os.path.exists(b ):
          die('Package "'+a+'" is not installed ??')
        p=open(b)
        s=p.read().split('\n')
        p.close()
        os.mkdir(TD+'/OLD/DATA')
        for a in s:
          if os.path.isfile(a) and not os.path.islink(a) :
            symlink_w_parents(a, TD+'/OLD/DATA')
a385 1
        os.mkdir(TD+'/OLD/DATA')
d400 2
a401 1
    shutil.move('NEW.file',newdeb)
d404 4
a407 1
      newdebsize = os.stat(newdeb)[ST_SIZE]
d410 1
a410 1
      print ' time: %dsec, speed:  %dkB per second ' % (a,(newdebsize / 1024 /  (a+1)))
d413 5
a417 2
elif action == 'delta' :
  olddeb = abspath(argv[0])
d420 2
a421 2
  
  newdeb = abspath(argv[1])
d425 6
a430 2
  
  delta = abspath(argv[2])
d483 11
a493 1
    
d524 4
a527 7
    try:
      a=os.statvfs(TD)
      freespace= a[0] * a[4]
    except a:
      if VERBOSE : print ' statvfs error ',a
      freespace = MAXMEMORY * 16
    if osize < MAXMEMORY / 17 and osize * 8 < freespace   :
d531 1
a531 1
      if VERBOSE > 2 : print '  fallback on xdelta instead of bsdiff' 
d539 1
a539 1
    if VERBOSE > 1 :
d554 1
a554 1
    
d563 1
d568 8
a575 2
    delta_files('OLD/mega_cat',n)
    #clean up
a576 1
    rmtree('OLD/'+w)
d604 1
a604 1
    if VERBOSE > 1: print ' studying ' , name , ' of len ' , newsize
d607 1
a607 1
    if VERBOSE > 2: print '  ar line: ',repr(s)
d642 2
a643 7
      deltacount += 1
      pp=str(deltacount)
      p = 'PATCH/'+pp
      if VERBOSE > 3 : print '   including "',name,'" verbatim in patch'
      os.rename(n,p)
      patch_append(pp)
      script.write('cat '+p+' >> NEW.file ; rm '+p+'\n')      
d684 3
a686 1

d688 2
a689 3
    print ' deb delta is  %3.1f'  % \
          ( deltasize * 100. /  newdebsize ) ,    '% of deb'
    print '  that is, %dkB would be saved ' % (( newdebsize -deltasize ) / 1024)
d691 48
a738 3
      end_sec = time.time()
      a=(end_sec - start_sec)
      print '  time: %dsec, speed: %dkB per second ' % (a,newdebsize / 1024 / (a+1))
d740 2
a741 4
####################################
else:
  #unimplemented action
  assert(0)
d743 69
a811 3
#cleanup
os.chdir(original_cwd)
rmtree(TD)
d814 2
a815 3
##   a='ar qSc result.deb '
##   for o in arlist['NEW'] :
##     a=a+ ' ' + o + ' '
d817 13
a829 3
##     '!<arch>\n'

##   a='fakeroot sh -c "chown root.root * ; ' + a + ' " '
d831 13
a843 1
##   s.write()
d845 5
a849 1
##   S(' cd NEW ; ' + a)
a850 47
##   ret=os.system('cmp NEW/result.deb '+newdeb )

##   if ret:
##     S('xdelta delta -n -9 '+newdeb+' NEW/result.deb ')
##   #S(['ar','qSc', 'temp.deb',]+ deltaparts)
##   #s.write('xdelta patch '+o+'.xdelta'+' ../OLD/'+o+' '+o+'\n')
  
##   def a(p,k,v):
##     if  p == None:
##       p = {}
##     if len(k) > 1  :
##       p[k[0]] = a(p.get(k[0]) , k[1:] ,v  )
##     else:
##       p[k[0]] = v
##       return p    

##     if '/' in s:
##       s=s.split('/')
##       if (len (s) == 2) :
##         ( a,  v ) = s
##         if '/' in s:
##           ....
##         params[ a  ] = v

##       elif (len (s) == 3) :
##         ( a, b, v ) = s
##         if a not in params :
##           params[a] ={}
##         params[ a ][b] = v
##       else:
##         print 'internal error on parm ', repr(s)


##     if False and DEBUG:
##       a=params['OLD/Package']
##       b='/var/lib/dpkg/info/' + a +'.list'
##       if os.path.exists(b ):
##         p=open(b)
##         s=p.read()
##         s=s.split('\n')
##         p.close()
##         for b in s :
##           if not ( b[1:] in oldnames ) :
##             print ' CASINO ',b
##         for b in oldnames : assert( '/'+b in s )
##       else:
##         print ' (package is not installed )',b
d852 1
@


1.11
log
@Added yet another die()
@
text
@d204 1
a204 1
    die('Error: '+f + ' does not exists.')
d212 1
a212 1
    die('Error: '+f + ' does not exists ')
@


1.10
log
@If -vv , display time to compute, and kB per second.

Use die() when files are not debs , or are not existant.
@
text
@d212 1
a212 1
    print f , ' does not exists '
@


1.9
log
@Option '--fs' is no more; new option '--needsold' (that is the opposite).

When error, invoke 'die()' that prints error and cleans up.

Treat 'control.tar.gz' as we treat 'data.tar.gz'.

In patch.sh, call './minigzip' and not 'minigzip'.
@
text
@d36 1
a36 1
import sys , os , tempfile , string ,getopt , tarfile , shutil
d45 3
a117 17
def check_deb(f):
  if not  os.path.isfile(f) :
    print f , ' does not exists '
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    print f , ' does not seem to be a Debian package '
    sys.exit(1)
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    print f , ' does not exists '
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    print f , ' does not seem to be a Debian delta '
    sys.exit(1)
  p.close()
d202 16
d227 5
a231 1
  else:
a235 4
    olddeb = abspath(argv[1])
    if olddeb != '/':
      check_deb(olddeb)
    
d333 6
a338 1
    
d601 6
a606 1
    print ' that is, %dkB would be saved ' % (( newdebsize -deltasize  ) / 1024)
@


1.8
log
@Can create deltas that can be used to recreate a new .deb using the
the installed of the old .deb.

--info is now only a 'debpatch' option ;
 debdelta always include the info.
@
text
@d10 3
d17 1
a17 3
  --fs    create a patch that can be used to recreate the new .deb
          from the old deb that is installed in the host.
          In this case, when using 'debpatch', use '/' for fromfile.
d19 1
d22 1
a23 1
  -d      debug : add md5sums, check installed version for --fs
d28 3
d41 1
d52 1
a52 1
                               ('help','info','fs') )
d54 1
a54 1
cwd = os.getcwd()
d61 1
a61 1
FS      = False
d67 1
a67 1
  elif o == '--fs' and action == 'delta' : FS = True
a114 8
def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    print ' error , non zero return status ',ret,' for ',a
    sys.exit(2)

d192 2
a193 1

d198 4
a201 1
if  VERBOSE > 1 :  print 'temporary in '+TD
d203 4
d209 7
d245 1
a245 1
  #lets see what it does and what it requires
d247 2
d265 1
d267 3
a269 1
    if olddeb != '/':
d271 4
a274 2

    if olddeb == '/' and DEBUG:
d276 5
a280 1
      p=os.popen('dpkg -s '+params['OLD/Package'])      
d283 10
a292 6
      for a in  dpkg_params:
        if  params[a] != dpkg_params[a] :
          print 'Error : in installed version , '+a+' = ' +dpkg_params[a]
          print '         in debdelta version , '+a+' = ' +params[a]          
          sys.exit(2)
      
d295 1
a295 1
        raise 'needs old version Debian package'
d299 1
a299 1
        raise 'needs old version Debian package'
d306 1
a306 1
          raise ' package "'+a+'" is not installed ??'
d318 9
d330 2
a331 13

    if 'old-data-tree' in params :
      shutil.rmtree('OLD/DATA')

    os.rename('NEW.file',newdeb)

  for o in  'PATCH/patch.sh','PATCH.file','minigzip','OLD.file':
    if os.path.exists(o):
      if VERBOSE > 5 : print ' deleting ',o
      unlink(o)
  for o in os.listdir('OLD'):
    if VERBOSE > 5 : print ' deleting OLD/',o
    unlink('OLD/'+o)
d412 1
a412 1
      script.write('minigzip -9 '+n+'\n')
d456 1
a456 1
  def delta_data(o,n):
d465 3
a467 3
      if  ('/'+name) in  old_conffiles :
        if VERBOSE > 3 : print '   skip conffile ', name
      elif name in oldnames and  newtarinfo.isreg()  :
d470 5
a474 5
          oldtar.extract(oldtarinfo.name,"OLD/DATA" )
          system('cat OLD/DATA/'+name+' >> OLD/data_mega_cat')
          unlink('OLD/DATA/'+name)
          script.write('cat OLD/DATA/'+name+'  >> OLD/data_mega_cat ; rm OLD/DATA/'+name+'\n')
    delta_files('OLD/data_mega_cat',n)
d477 1
a477 1
    shutil.rmtree('OLD/DATA')
d482 1
a482 1
  if not  FS:
d523 2
a524 2
    elif False and name[:11] == 'control.tar' :
      #TODO
d526 11
a536 1
    elif FS and name[:8] == 'data.tar'  :
d540 1
a540 1
      delta_data(o,n)
d542 1
a542 1
    elif  FS or name not in ar_list_old :       #or it is not in old deb
d550 1
a550 1
    elif not FS:
d558 1
a558 1
      raise
a588 3
  shutil.rmtree('OLD/CONTROL')
  shutil.rmtree('NEW/CONTROL')
    
a589 2
  unlink('NEW.file')
  unlink('OLD.file')
d601 2
a602 5
os.chdir(TD)
rmdir('PATCH')
rmdir('OLD')
rmdir('NEW')
rmdir(TD)
d664 2
@


1.7
log
@'debpatch --info' accepts only 1 argument.

When old ar component was missing, must 'patch_append(p)' it.
@
text
@d14 1
a14 1
  --fs    create a (larger) patch that can be used to recreate the new .deb
d17 1
a17 3
  -d      debug : add md5sums to patch
 --noinfo do not insert in patch the info on two Debian files
  -M Mb   maximum memory (decides between using 'bsdiff' or 'xdelta')
d21 2
a22 1
  -v      verbose (can be added multiple times
d31 1
a31 1
import sys , os , tempfile , string ,getopt
d51 1
a51 1
DEBUG   = 0
d54 1
a54 1
INFO    = action == 'delta'
d59 1
a59 1
  elif o == '-d' and action == 'delta' : DEBUG += 1
d63 1
a63 2
  elif o == '--info' : INFO = True
  elif o == '--noinfo' : INFO = False 
d71 1
a71 1
if INFO and action == 'patch' :
d82 27
d153 12
d199 1
a199 1
if DEBUG or VERBOSE > 1 :  print 'temporary in '+TD
d237 9
a245 8
  while s and s[0] == '#':
    s=de_n(s)[1:]
    if VERBOSE or INFO : print ' info: ',s
    if ':' in s:
      i=s.index(':')  
      params[s[:i]] = s[i+1:]
    else:
      params[s] = True
d251 14
d269 5
a273 3
      os.symlink(olddeb,TD+'/OLD.file')
    
    if 'needs-old' in params:
d275 14
a288 2
        raise 'needs old version Debian package'
      os.symlink(olddeb,TD+'/OLD.file')
d294 3
a332 15
  ##### write parameters
  if DEBUG or INFO:
    for o in 'OLD', 'NEW' :
      if INFO : print o
      system('ar p  '+o+'.file control.tar.gz | tar xzf - ./control')
      p=open('control')
      a=p.readline()
      while a:
        a=de_n(a)
        if a[:3] in ('Pac','Ver','Arc'):
          if DEBUG : script.write('#'+o+'/'+a+'\n')
          if INFO : print ' ' , a
        a=p.readline()
      p.close()
    unlink('control')
d335 1
d339 16
d356 8
a363 5
  #this delta needs the old deb , unpacked in 'OLD'
  #script.write('#unpack-old\n')
  #this delta needs the old deb 
  script.write('#needs-old\n')

d372 1
a372 1
  def unzip(f):
d376 1
a376 1
      if f[:3] != 'NEW' :
a421 1

d430 30
a459 1
  ############# start scanning the new deb
d463 1
a470 1

d497 10
a506 1
    elif  name not in ar_list_old :       #or it is not in old deb
d508 3
a510 1
      p = 'PATCH/'+str(deltacount)
d512 3
a514 4
      patch_append(p)
      script.write('echo PATCH/'+o+' >> NEW.file')
      if DEBUG: script.write('rm PATCH/'+o+'\n')
    else:
d521 2
d543 12
a554 4
  script.close()  
  system('gzip -9 -n PATCH/patch.sh')
  
  patch_append('patch.sh.gz')
d620 16
@


1.6
log
@Use bsdiff when memory does not exceed 50Mb, and free disk space is enough;

' debpatch --info  patch' to just know info on a patch

Shipped in packagde 0.3
@
text
@d14 1
a14 1
  --fs    TODO: create a (larger) patch that can be used to recreate the new .deb
d73 7
a79 1
if len(argv) != 3  :  
d81 1
a81 1
  sys.exit(0)
d232 1
d235 1
a235 1
    if DEBUG: print ' deleting OLD/',o
a252 3
  #unpack('OLD',olddeb)
  #unpack('NEW',newdeb)

a255 2
  #components of this patch
  deltaparts=['patch.sh.gz']
a326 1
    #deltaparts.append(str(deltacount))
d399 1
a399 1
      deltaparts.append(p)
@


1.5
log
@This version uses bspatch / bsdiff ... but it uses too much memory.
@
text
@d3 2
a4 1
"""debdelta [ option...  ] fromfile tofile patchout
d7 1
a7 1
debpatch [ option...  ] patchin  fromfile  tofile 
d10 5
a14 3
Options for debpatch:
  --fs    TODO
          create a (larger) patch that can be used to recreate the new .deb
d18 4
d23 1
a23 1
  -v      verbose
a24 1
  --info  print info on two Debian files
d46 1
a46 1
( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhd' ,
d51 1
d53 1
a53 1
VERBOSE = 1
d55 1
a55 1
INFO    = False
d62 4
a65 2
  elif o == '--fs' and action == 'delta' : FS = True  
  elif o == '--info' : INFO = True  
a72 3

#should use getopt.gnu_getopt

d87 2
d96 2
d109 2
a110 2
def unpack(d,f):
  "unpacks 'ar' file f in directory d"
d112 1
a112 4

  os.symlink(f,TD+'/'+d+'.file')
  
  arlist[d] = []
d118 1
a118 1
    arlist[d].append(a)    
d120 2
d123 3
d158 1
a158 1
arlist = {}
d162 1
a162 5
if action == 'patch':
  newdeb = abspath(argv[2])
  if  os.path.exists(newdeb) :
    os.rename(newdeb,newdeb+'~')
  
a164 5
  
  olddeb = abspath(argv[1])
  check_deb(olddeb)

  unpack ('PATCH',delta)
d166 13
d181 1
a181 1

d184 1
a184 1
  if 'patch.sh.gz' in  arlist['PATCH']:
d186 2
a187 2
  elif 'patch.sh.bz2' in  arlist['PATCH']:
    system('bunzip2 PATCH/patch.sh.bz2')
d192 1
a192 1
  s=p.readline()
d195 2
a196 1
    s=de_n(s)[1:]    
d198 2
a199 3
      (a , b) = s.split(':')
      b = b[1:] 
      params[a] = b      
a204 1
  if VERBOSE : print ' info:',repr(params)
d206 15
a220 4
  if 'unpack-old' in params:
    unpack ('OLD',olddeb)
  
  system('/bin/sh -e PATCH/patch.sh')
d222 1
a222 1
  os.rename('NEW.file',newdeb)
d235 2
a236 1

d239 1
d246 2
a247 2
  unpack('OLD',olddeb)
  unpack('NEW',newdeb)
d255 1
d266 1
a266 1
      system('tar xzf '+o+'/control.tar.gz ./control')
d272 1
a272 1
          if DEBUG : script.write('#'+o+':'+a+'\n')
d284 72
a355 2
  script.write('#unpack-old\n')
  
d357 3
a359 1
    
d367 10
a376 4
    
  for o in arlist['NEW'] :
    oldsize = os.stat('NEW/'+o)[ST_SIZE]
    if VERBOSE > 1: print 'studying ',o,' of len ',oldsize
d379 2
a380 2
    if VERBOSE > 2: print 'ar line: ',repr(s)
    assert( s[:len(o)] == o and s[-2] == '`' and s[-1] == '\n' )
d383 2
a384 2
    newdeb_file.seek(oldsize  ,1)
    if oldsize & 1 :
d389 3
a391 3
    if oldsize < 128:      #file is too short to compute a delta,
      p=open('NEW/'+o)
      append( p.read(oldsize))
d393 6
a398 6
      unlink('NEW/'+o)
      if o in arlist['OLD'] :
        unlink('OLD/'+o)
    elif  o not in arlist['OLD'] :       #or it is not in old deb
      os.rename('NEW/'+o,'PATCH/'+o)
      deltaparts.append(o)
d403 6
a408 30
      c=''
      if o[-3:] == '.gz' :
        #cannot gunzip if there is a link ! os.link('NEW/'+o,'tmp_n')
        o=o[:-3]
        system('gunzip  NEW/'+o+'.gz')
        system('gunzip  OLD/'+o+'.gz')
        c='.gz'
      elif  o[-3:] == '.bz2' :
        print 'WARNING ! ',o,' is in BZIP2 format ! please fixme !'
      system('bsdiff  OLD/'+o+' NEW/'+o+' PATCH/'+o+'.bsdiff')
      deltaparts.append(o+'.bsdiff')
      unlink('NEW/'+o)
      unlink('OLD/'+o)
      ## how did we fare ?
      deltasize = os.stat('PATCH/'+o+'.bsdiff')[ST_SIZE]
      if VERBOSE > 1 :
        print ' delta is  %3.4f'  % ( deltasize * 100. /  oldsize ) , '% of ',o
      elif  (deltasize > oldsize  and DEBUG): 
        print 'this sucks: deltasize ',deltasize,' > oldsize ',oldsize
      ## and prepare the script consequently
      if c == '.gz':
        script.write('gunzip OLD/'+o+'.gz\n')  
      script.write('bspatch OLD/'+o+' NEW/'+o+' PATCH/'+o+'.bsdiff\n')
      script.write('rm PATCH/'+o+'.bsdiff OLD/'+o+'\n')
      if c == '.gz' :
        script.write('minigzip -9 NEW/'+o+'\n')
      if DEBUG:
        pass #implement MD5
      script.write('cat NEW/'+o+c+' >> NEW.file\n')
      script.write('rm NEW/'+o+c+'\n')
a412 1
  if VERBOSE > 2: print ' ar leftover character: ',repr(s)
d414 1
d418 8
a425 1
    pass #implement MD5
d430 2
a431 7
  #create final debdelta
  os.chdir(TD+'/PATCH')  
  system(['ar','qSc', delta,]+ deltaparts)
  for o in deltaparts:
    unlink(o)

  os.chdir(TD)
d473 24
@


1.4
log
@Added getopt support.
Reorganized code.
Be careful of cwd when using os.path.abspath.
Add parameters to patch.sh , in particular,
 support for '#unpack-old' keyword
Graduated verbosity.
@
text
@d144 1
a144 1
if DEBUG :  print 'temporary in '+TD
d177 1
d181 3
a183 2
      i=s.index(':')
      params[s[:i]] = s[i+1:]
d226 2
d305 2
a306 4
      s= '-n'
      if DEBUG: s=''
      system('xdelta delta '+s+' -9 OLD/'+o+' NEW/'+o+' PATCH/'+o+'.xdelta')
      deltaparts.append(o+'.xdelta')
d310 1
a310 1
      deltasize = os.stat('PATCH/'+o+'.xdelta')[ST_SIZE]
d318 2
a319 2
      script.write('xdelta patch PATCH/'+o+'.xdelta OLD/'+o+' NEW/'+o+'\n')
      script.write('rm PATCH/'+o+'.xdelta OLD/'+o+'\n')
@


1.3
log
@can build diff of two .debs and patch one to get the other
(debian version 0.1)
@
text
@d3 2
a4 3
__doc__ = """
   debelta
       The debdelta command has the following synopsis:
d6 2
a7 1
       debdelta [ option...  ] fromfile tofile patchout
d9 10
a18 9
       Computes a delta from fromfile to tofile and writes it to patchout

   debpatch
       The debpatch command has the following synopsis:

       debpatch [ option...  ] patchin  fromfile  tofile 

       Applies patchin to fromfile and produces  a  reconstructed  version  of
       tofile.
a22 5
DEBUG   = True
VERBOSE = 1
KEEP    = False 

actions =  ('delta','patch')
d26 1
a26 1
import sys , os , tempfile , string
d34 38
d113 2
a114 1
  
d117 1
a117 1
  os.chdir(TD)
d120 1
a120 1
ALLOWED = '<>()[]{}.,;:_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
a139 12
#should use getopt.gnu_getopt

if len(sys.argv) <= 1 or sys.argv[1] == '--help' or sys.argv[1] == '-h' :
  print __doc__
  sys.exit(0)

action=(os.path.basename(sys.argv[0]))[3:]

if action not in actions:
  print 'wrong action: may be '+repr(actions)

argv=sys.argv[1:]
a156 2

  unpack ('PATCH',delta)
d161 2
d230 1
a230 1
  if DEBUG:
d232 1
d239 2
a240 1
          script.write('#'+o+a+'\n')
a244 4
  #this delta needs the old deb , unpacked in 'OLD'
  script.write('#unpack-old\n')

  
d249 4
d265 1
a265 1
    if VERBOSE: print 'studying ',o,' of len ',oldsize
d268 1
a268 1
    if VERBOSE > 1: print 'ar line: ',repr(s)
d309 1
a309 1
      if VERBOSE :
d328 1
a328 1
  if VERBOSE: print 'leftover: ',repr(s)
d351 1
a351 1
    print ' deb delta is  %3.4f'  % \
d353 1
@


1.2
log
@this works, it creates deltas that can rebuild the exact .deb
@
text
@d20 1
a20 1
minigzip='/home/andrea/bin/minigzip'
d60 26
a85 1
ALLOWED = '. abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
d111 1
a111 1
action=sys.argv[0][-5:]
d118 4
d123 1
a123 17
if action == 'delta' :
  olddeb = abspath(argv[0])
  check_deb(olddeb)

  newdeb = abspath(argv[1])
  check_deb(newdeb)
  newdebsize = os.stat(newdeb)[ST_SIZE]
  
  delta = abspath(argv[2])
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  pairs = [ ('OLD',olddeb) , ('NEW',newdeb) ]
  
elif action == 'patch':
  olddeb = abspath(argv[1])
  check_deb(olddeb)
d125 1
d127 1
a133 3
  pairs = [ ('OLD',olddeb) , ('PATCH',delta) ]
else:
  assert(0)
d135 4
a138 4
TD = abspath(tempfile.mkdtemp())
if DEBUG :  print 'temporary in '+TD
#from here on, we live in the temp dir
os.chdir(TD)
d140 2
a141 1
arlist = {}
d143 1
a143 3
##################
for (d,f) in pairs :
  assert(os.path.exists(f))
d145 17
a161 10
  #os.symlink(f,TD+'/'+d+'.file')
  
  arlist[d] = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    if a[-1] ==  '\n' :
      a = a[:-1]
    arlist[d].append(a)    
d164 1
a164 6
  os.mkdir(d)  
  os.chdir(d)
  system('ar xo '+f)
  os.chdir(TD)
  
################# compute patch
d166 2
a167 4
if action == 'patch':
  os.symlink(minigzip,'minigzip')
  
  os.mkdir(TD+'/NEW')
a168 1
  system('gunzip PATCH/patch.sh.gz')
d173 8
a180 1
############## compute delta
d182 17
a198 1
  os.mkdir(TD+'/PATCH')
d206 18
d228 2
d264 1
d314 1
a314 1
  os.chdir(TD+'/PATCH')
d318 1
d320 1
a320 5
  rmdir('PATCH')
  rmdir('OLD')
  rmdir('NEW')
  rmdir(TD)
  
d322 10
a331 3
  
  print ' deb delta is  %3.4f'  % ( deltasize * 100. /  newdebsize ) , '% of deb'
  
d333 6
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
   Delta
       The delta subcommand has the following synopsis:
d7 1
a7 1
       debdelta delta [ option...  ] fromfile tofile patchout
d11 2
a12 2
   Patch
       The patch subcommand has the following synopsis:
d14 1
a14 1
       debdelta patch [ option...  ] patchin [ fromfile [ tofile ]]
d20 6
a25 1
minigzip='~/bin/minigzip'
d28 3
a30 1
import sys,os,tempfile , string
d36 1
a36 1
DEBUG =True
d38 41
a78 4
#def unlink(a):
#  print ' unlink ',a
#def rmdir(a):
#  print ' rmdir ',a
d82 1
a82 1
if len(sys.argv) <= 1 or sys.argv[1] == '--help' :
d86 1
a86 1
action=sys.argv[1]
d91 1
a91 1
argv=sys.argv[2:]
a92 3
TD = tempfile.mkdtemp()

if DEBUG :  print 'temporary in '+TD
d96 2
d99 1
d101 1
a105 1
  os.mkdir(TD+'/PATCH')
d107 1
d110 3
d114 5
a118 1
  delta = abspath(argv[0]) 
d123 3
a125 8
def S(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    print ' error , non zero return status ',ret,' for ',a
    sys.exit(2)
  
d129 2
a130 1
  
a131 3
  os.chdir(TD)
  os.mkdir(d)
  os.chdir(d)
d133 3
d143 1
a143 2
    arlist[d].append(a)
    
d145 4
a148 1
  S('ar xo '+f)
d151 1
a151 1
os.chdir(TD)
d154 8
a161 4
  os.chdir(TD+'/PATCH')
  S('gunzip patch.sh.gz')
  S('/bin/sh patch.sh')
  os.rename('result.deb',newdeb)
d163 1
d165 1
d168 1
d170 12
a181 2
  s=open('PATCH/patch.sh','w')
  s.write('#!/bin/sh -e\n')
d184 1
a184 1
  
d187 21
a207 1
    if o not in arlist['OLD'] or oldsize < 128:
a208 1
      unlink('OLD/'+o)
d210 1
d212 1
d217 2
a218 2
        S('gunzip -cv NEW/'+o+'.gz > ' + 'NEW/'+o)
        S('gunzip -cv OLD/'+o+'.gz > ' + 'OLD/'+o)
d220 6
a225 14
      S('xdelta delta -n -V -9 OLD/'+o+' NEW/'+o+' PATCH/'+o+'.xdelta')      
      deltasize = os.stat('PATCH/'+o+'.xdelta')[ST_SIZE]
      if deltasize > oldsize  :
        print 'bello schifo ',deltasize,' > ',oldsize
      if 1:
        if c == '.gz':
          s.write('gunzip ../OLD/'+o+'.gz\n')  
        deltaparts.append(o+'.xdelta')
        s.write('xdelta patch '+o+'.xdelta'+' ../OLD/'+o+' '+o+'\n')
        s.write('rm '+o+'.xdelta ../OLD/'+o+'\n')
        if c == '.gz' :
          s.write(minigzip+' -9 '+o+'\n')
          if DEBUG:
            pass
d228 32
a259 23
      if c:
        unlink('NEW/'+o+c)
        unlink('OLD/'+o+c)

  a='ar qSc result.deb '
  for o in arlist['NEW'] :
    a=a+ ' ' + o + ' '

  a='fakeroot sh -c "chown root.root * ; ' + a + ' " '
  
  s.write()
  
  S(' cd NEW ; ' + a)

  ret=os.system('cmp NEW/result.deb '+newdeb )

  if ret:
    S('xdelta delta -n -9 '+newdeb+' NEW/result.deb ')
  #S(['ar','qSc', 'temp.deb',]+ deltaparts)
  #s.write('xdelta patch '+o+'.xdelta'+' ../OLD/'+o+' '+o+'\n')
  
  s.close()
  S('gzip -9 PATCH/patch.sh')
d261 1
a261 1
  S(['ar','qSc', delta,]+ deltaparts)
d274 22
@
