#!/usr/bin/python

__doc__ = """
   debelta
       The debdelta command has the following synopsis:

       debdelta [ option...  ] fromfile tofile patchout

       Computes a delta from fromfile to tofile and writes it to patchout

   debpatch
       The debpatch command has the following synopsis:

       debpatch [ option...  ] patchin  fromfile  tofile 

       Applies patchin to fromfile and produces  a  reconstructed  version  of
       tofile.
"""

minigzip='/usr/lib/debdelta/minigzip'

DEBUG   = True
VERBOSE = 1
KEEP    = False 

actions =  ('delta','patch')

####################################################################

import sys , os , tempfile , string

from stat    import ST_SIZE
from os.path import abspath
from os      import unlink, rmdir

####################################################################

def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    print ' error , non zero return status ',ret,' for ',a
    sys.exit(2)

def check_deb(f):
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    print f , ' does not seem to be a Debian package '
    sys.exit(1)
  p.close()

def check_diff(f):
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    print f , ' does not seem to be a Debian delta '
    sys.exit(1)
  p.close()

def de_n(a):
  if a[-1] ==  '\n' :
    a = a[:-1]
  return a

def unpack(d,f):
  "unpacks 'ar' file f in directory d"
  assert(os.path.exists(f))

  os.symlink(f,TD+'/'+d+'.file')
  
  arlist[d] = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    arlist[d].append(a)    
  p.close()
  
  os.chdir(TD+'/'+d)
  system('ar xo '+f)
  os.chdir(TD)


ALLOWED = '<>()[]{}.,;:_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r

####################################################################
if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a

#should use getopt.gnu_getopt

if len(sys.argv) <= 1 or sys.argv[1] == '--help' or sys.argv[1] == '-h' :
  print __doc__
  sys.exit(0)

action=(os.path.basename(sys.argv[0]))[3:]

if action not in actions:
  print 'wrong action: may be '+repr(actions)

argv=sys.argv[1:]

TD = abspath(tempfile.mkdtemp())
for i in 'OLD','NEW','PATCH' :
  os.mkdir(TD+'/'+i)
if DEBUG :  print 'temporary in '+TD

arlist = {}
  
#################################################################### apply patch

if action == 'patch':
  newdeb = abspath(argv[2])
  if  os.path.exists(newdeb) :
    os.rename(newdeb,newdeb+'~')
  
  delta = abspath(argv[0])
  check_diff(delta)

  unpack ('PATCH',delta)
  
  olddeb = abspath(argv[1])
  check_deb(olddeb)

  #from here on, we live in the temp dir
  os.chdir(TD)

  os.symlink(minigzip,'minigzip')

  if 'patch.sh.gz' in  arlist['PATCH']:
    system('gunzip PATCH/patch.sh.gz')
  elif 'patch.sh.bz2' in  arlist['PATCH']:
    system('bunzip2 PATCH/patch.sh.bz2')

  #lets see what it does and what it requires
  params={}
  p=open('PATCH/patch.sh')
  s=p.readline()
  while s and s[0] == '#':
    s=de_n(s)[1:]    
    if ':' in s:
      i=s.index(':')
      params[s[:i]] = s[i+1:]
    else:
      params[s] = True
    s=p.readline()
  p.close()

  if VERBOSE : print ' info:',repr(params)

  if 'unpack-old' in params:
    unpack ('OLD',olddeb)
  
  system('/bin/sh -e PATCH/patch.sh')

  os.rename('NEW.file',newdeb)

  for o in  'PATCH/patch.sh','PATCH.file','minigzip','OLD.file':
    if os.path.exists(o):
      unlink(o)
  for o in os.listdir('OLD'):
    if DEBUG: print ' deleting OLD/',o
    unlink('OLD/'+o)

##################################################### compute delta
elif action == 'delta' :
  olddeb = abspath(argv[0])
  check_deb(olddeb)

  newdeb = abspath(argv[1])
  check_deb(newdeb)
  newdebsize = os.stat(newdeb)[ST_SIZE]
  
  delta = abspath(argv[2])
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  unpack('OLD',olddeb)
  unpack('NEW',newdeb)

  #from here on, we live in the temp dir
  os.chdir(TD)

  #components of this patch
  deltaparts=['patch.sh.gz']

  #start writing script 
  script=open('PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')

  ##### write parameters
  if DEBUG:
    for o in 'OLD', 'NEW' :
      system('tar xzf '+o+'/control.tar.gz ./control')
      p=open('control')
      a=p.readline()
      while a:
        a=de_n(a)
        if a[:3] in ('Pac','Ver','Arc'):
          script.write('#'+o+a+'\n')
        a=p.readline()
      p.close()
    unlink('control')

  #this delta needs the old deb , unpacked in 'OLD'
  script.write('#unpack-old\n')

  
  def append(s):
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")

  ############# start scanning the new deb
    
  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append(s)

  #process all contents of old vs new .deb
    
  for o in arlist['NEW'] :
    oldsize = os.stat('NEW/'+o)[ST_SIZE]
    if VERBOSE: print 'studying ',o,' of len ',oldsize
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 1: print 'ar line: ',repr(s)
    assert( s[:len(o)] == o and s[-2] == '`' and s[-1] == '\n' )
    append(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(oldsize  ,1)
    if oldsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if oldsize < 128:      #file is too short to compute a delta,
      p=open('NEW/'+o)
      append( p.read(oldsize))
      p.close()
      unlink('NEW/'+o)
      if o in arlist['OLD'] :
        unlink('OLD/'+o)
    elif  o not in arlist['OLD'] :       #or it is not in old deb
      os.rename('NEW/'+o,'PATCH/'+o)
      deltaparts.append(o)
      script.write('echo PATCH/'+o+' >> NEW.file')
      if DEBUG: script.write('rm PATCH/'+o+'\n')
    else:
      #file is long, and has old version ; lets compute a delta
      c=''
      if o[-3:] == '.gz' :
        #cannot gunzip if there is a link ! os.link('NEW/'+o,'tmp_n')
        o=o[:-3]
        system('gunzip  NEW/'+o+'.gz')
        system('gunzip  OLD/'+o+'.gz')
        c='.gz'
      elif  o[-3:] == '.bz2' :
        print 'WARNING ! ',o,' is in BZIP2 format ! please fixme !'
      s= '-n'
      if DEBUG: s=''
      system('xdelta delta '+s+' -9 OLD/'+o+' NEW/'+o+' PATCH/'+o+'.xdelta')
      deltaparts.append(o+'.xdelta')
      unlink('NEW/'+o)
      unlink('OLD/'+o)
      ## how did we fare ?
      deltasize = os.stat('PATCH/'+o+'.xdelta')[ST_SIZE]
      if VERBOSE :
        print ' delta is  %3.4f'  % ( deltasize * 100. /  oldsize ) , '% of ',o
      elif  (deltasize > oldsize  and DEBUG): 
        print 'this sucks: deltasize ',deltasize,' > oldsize ',oldsize
      ## and prepare the script consequently
      if c == '.gz':
        script.write('gunzip OLD/'+o+'.gz\n')  
      script.write('xdelta patch PATCH/'+o+'.xdelta OLD/'+o+' NEW/'+o+'\n')
      script.write('rm PATCH/'+o+'.xdelta OLD/'+o+'\n')
      if c == '.gz' :
        script.write('minigzip -9 NEW/'+o+'\n')
      if DEBUG:
        pass #implement MD5
      script.write('cat NEW/'+o+c+' >> NEW.file\n')
      script.write('rm NEW/'+o+c+'\n')
    if extrachar :
      append(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if VERBOSE: print 'leftover: ',repr(s)
  if s:
    append(s)

  if DEBUG:
    pass #implement MD5

  #script is done
  script.close()  
  system('gzip -9 -n PATCH/patch.sh')
  #create final debdelta
  os.chdir(TD+'/PATCH')  
  system(['ar','qSc', delta,]+ deltaparts)
  for o in deltaparts:
    unlink(o)

  os.chdir(TD)
    
  deltasize = os.stat(delta)[ST_SIZE]
  unlink('NEW.file')
  unlink('OLD.file')

  if VERBOSE:
    print ' deb delta is  %3.4f'  % \
          ( deltasize * 100. /  newdebsize ) ,    '% of deb'
####################################
else:
  #unimplemented action
  assert(0)

#cleanup
os.chdir(TD)
rmdir('PATCH')
rmdir('OLD')
rmdir('NEW')
rmdir(TD)


##   a='ar qSc result.deb '
##   for o in arlist['NEW'] :
##     a=a+ ' ' + o + ' '

##     '!<arch>\n'

##   a='fakeroot sh -c "chown root.root * ; ' + a + ' " '
  
##   s.write()
  
##   S(' cd NEW ; ' + a)

##   ret=os.system('cmp NEW/result.deb '+newdeb )

##   if ret:
##     S('xdelta delta -n -9 '+newdeb+' NEW/result.deb ')
##   #S(['ar','qSc', 'temp.deb',]+ deltaparts)
##   #s.write('xdelta patch '+o+'.xdelta'+' ../OLD/'+o+' '+o+'\n')
  
