#!/usr/bin/python

"""\
Usage: debdelta [ option...  ] fromfile tofile patchout
  Computes a delta from fromfile to tofile and writes it to patchout

Usage: debpatch [ option...  ] patchin  fromfile  tofile 
  Applies patchin to fromfile and produces  a  reconstructed  version of tofile.

Usage: debpatch --info  patch
  Write info on patch.

Options for debdelta:
  --fs    create a patch that can be used to recreate the new .deb
          from the old deb that is installed in the host.
          In this case, when using 'debpatch', use '/' for fromfile.
  -M Mb   maximum memory (to decide if using 'bsdiff' or 'xdelta')
Options for debpatch:
 --info  print info on two Debian files, and exists
Options for both:
  -d      debug : add md5sums, check installed version for --fs
  -v      verbose (can be added multiple times)
  -k      keep temporary files
"""

minigzip='/usr/lib/debdelta/minigzip'


####################################################################

import sys , os , tempfile , string ,getopt , tarfile , shutil

from stat    import ST_SIZE
from os.path import abspath
from os      import unlink, rmdir

####################################################################

action=(os.path.basename(sys.argv[0]))[3:]
actions =  ('delta','patch')
if action not in actions:
  print 'wrong filename: should be "deb" + '+repr(actions)
  sys.exit(0)

( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                               ('help','info','fs') )

cwd = os.getcwd()

MAXMEMORY = 1024 * 1024 * 50
DEBUG   = 1
VERBOSE = 0
KEEP    = False
INFO    = False
FS      = False

for  o , v  in  opts :
  if o == '-v' : VERBOSE += 1
  elif o == '-d' : DEBUG += 1
  elif o == '-k' : KEEP = True
  elif o == '--fs' and action == 'delta' : FS = True
  elif o == '-M' and action == 'delta' :    MAXMEMORY = 1024 * 1024 * int(v)
  elif o == '--info' and action == 'patch' : INFO = True
  elif o ==  '--help' or o ==  '-h':
    print __doc__
    sys.exit(0)
  else:
    print ' option ',o,'is unknown, try --help'
    sys.exit(1)

if INFO  :
  if  len(argv) > 1 and VERBOSE :
    print '(printing info - extra arguments are ignored)'
  elif  len(argv) == 0  :
    print ' need a  filename ;  try --help'
    sys.exit(1)
elif len(argv) != 3  or ( len(argv) != 3   ):  
  print ' need 3 filenames ;  try --help'
  sys.exit(1)

######################################################################

dpkg_keeps_controls = (
  'conffiles','config','list','md5sums','postinst',
  'postrm','preinst','prerm','shlibs','templates')

def scan_control(p,params,prefix,script=None,stdout = None):
  a=p.readline()
  while a:
    a=de_n(a)
    if a[:3] in ('Pac','Ver','Arc'):
      if script : script.write('#'+prefix+'/'+a+'\n')
      if stdout : stdout.write(' ' + a)
      i=a.index(':')
      assert(a[i:i+2] == ': ')
      params[prefix+'/'+a[:i]] = a[i+2:]
    a=p.readline()

def symlink_w_parents(f,d):
  s=f.split('/') 
  for a in s[:-1] :
    if a:
      d = d + '/' + a
      if not os.path.exists(d):
        os.mkdir(d)      
  d += '/'+s[-1]
  os.symlink(f,d)

def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    print ' error , non zero return status ',ret,' for ',a
    sys.exit(2)

def check_deb(f):
  if not  os.path.isfile(f) :
    print f , ' does not exists '
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    print f , ' does not seem to be a Debian package '
    sys.exit(1)
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    print f , ' does not exists '
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    print f , ' does not seem to be a Debian delta '
    sys.exit(1)
  p.close()

def de_n(a):
  if a[-1] ==  '\n' :
    a = a[:-1]
  return a


def list_ar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list

def list_tar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('tar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list


def unpack(d,f):
  "unpacks 'ar' file f in directory d"
  assert(os.path.exists(f))
  cwd = os.getcwd()
  os.chdir(TD+'/'+d)
  system('ar xo '+f)
  os.chdir(cwd)


ALLOWED = '<>()[]{}.,;:!_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r

####################################################################
if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a


TD = abspath(tempfile.mkdtemp())
for i in 'OLD','NEW','PATCH' :
  os.mkdir(TD+'/'+i)
if  VERBOSE > 1 :  print 'temporary in '+TD


  
#################################################################### apply patch

if action == 'patch':  
  delta = abspath(argv[0])
  check_diff(delta)

  if INFO:
    os.chdir(TD+'/PATCH')
    system('ar x  '+delta+' patch.sh patch.sh.gz patch.sh.bz2 2> /dev/null')
  else:
    newdeb = abspath(argv[2])
    if  os.path.exists(newdeb) :
      os.rename(newdeb,newdeb+'~')
    
    olddeb = abspath(argv[1])
    if olddeb != '/':
      check_deb(olddeb)
    
    unpack ('PATCH',delta)
  #from here on, we live in the temp dir
  os.chdir(TD)
    
  os.symlink(minigzip,'minigzip')

  if os.path.exists('PATCH/patch.sh.gz'):
    system('gunzip PATCH/patch.sh.gz')
  elif os.path.exists('PATCH/patch.sh.bz2'):
    system('bunzip2 PATCH/patch.sh.bz2')  

  #lets see what it does and what it requires
  params={}
  p=open('PATCH/patch.sh')
  s=p.readline()#skip #!/bin/sh
  s=p.readline()
  while s :
    if s[0] == '#' :
      s=de_n(s)[1:]
      if VERBOSE or INFO : print ' info: ',s
      if ':' in s:
        i=s.index(':')  
        params[s[:i]] = s[i+2:]
      else:
        params[s] = True
    s=p.readline()
  p.close()


  if not INFO:
    if olddeb != '/':
      os.symlink(olddeb,TD+'/OLD.file')

    if olddeb == '/' and DEBUG:
      dpkg_params={}
      p=os.popen('dpkg -s '+params['OLD/Package'])      
      scan_control(p,dpkg_params,'OLD')
      p.close()
      for a in  dpkg_params:
        if  params[a] != dpkg_params[a] :
          print 'Error : in installed version , '+a+' = ' +dpkg_params[a]
          print '         in debdelta version , '+a+' = ' +params[a]          
          sys.exit(2)
      
    if 'unpack-old' in params:
      if olddeb == '/':
        raise 'needs old version Debian package'
      unpack ('OLD',olddeb)

    if 'needs-old' in params and olddeb == '/':
        raise 'needs old version Debian package'

    if 'old-data-tree' in params :
      if olddeb == '/':
        a=params['OLD/Package']
        b='/var/lib/dpkg/info/' + a +'.list'
        if not os.path.exists(b ):
          raise ' package "'+a+'" is not installed ??'
        p=open(b)
        s=p.read().split('\n')
        p.close()
        os.mkdir(TD+'/OLD/DATA')
        for a in s:
          if os.path.isfile(a) and not os.path.islink(a) :
            symlink_w_parents(a, TD+'/OLD/DATA')
      else:
        os.mkdir(TD+'/OLD/DATA')
        system('ar p OLD.file data.tar.gz | tar -x -z -f - -C OLD/DATA')

    a=''
    if VERBOSE > 2 : a = '-v'
    system('/bin/sh -e '+a+' PATCH/patch.sh')

    if 'old-data-tree' in params :
      shutil.rmtree('OLD/DATA')

    os.rename('NEW.file',newdeb)

  for o in  'PATCH/patch.sh','PATCH.file','minigzip','OLD.file':
    if os.path.exists(o):
      if VERBOSE > 5 : print ' deleting ',o
      unlink(o)
  for o in os.listdir('OLD'):
    if VERBOSE > 5 : print ' deleting OLD/',o
    unlink('OLD/'+o)

##################################################### compute delta
elif action == 'delta' :
  olddeb = abspath(argv[0])
  check_deb(olddeb)
  os.symlink(olddeb,TD+'/OLD.file')
  
  newdeb = abspath(argv[1])
  check_deb(newdeb)
  os.symlink(newdeb,TD+'/NEW.file')
  newdebsize = os.stat(newdeb)[ST_SIZE]
  
  delta = abspath(argv[2])
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  #from here on, we live in the temp dir
  os.chdir(TD)

  #counter for numbered files
  global deltacount
  deltacount = 0 

  #start writing script 
  script=open('PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')


  def append(s):
    'appends some data to NEW.file'
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")

  ##### unpack control.tar.gz, scan control, write  parameters
  params={}
  for o in 'OLD', 'NEW' :
      os.mkdir(TD+'/'+o+'/CONTROL')
      #unpack control.tar.gz
      system('ar p '+o+'.file control.tar.gz | tar -x -z -f - -C '+o+'/CONTROL')
      ## scan control
      if  VERBOSE > 1 :
        print o
        s=sys.stdout
      else:
        s=None
      p=open(TD+'/'+o+'/CONTROL/control') 
      scan_control(p,params,o,script,s)
      p.close()
      if s: print

  ## check for conffiles 
  a=TD+'/OLD/CONTROL/conffiles'
  if os.path.exists(a):
    p=open(a)
    old_conffiles=p.read().split('\n')
    p.close()
  else:
    old_conffiles=()
  ############### some routines  to prepare delta of two files

  def patch_append(f):
    os.chdir(TD+'/PATCH')
    system(['ar','qSc', delta,f])
    unlink(f)
    os.chdir(TD)
    
  def unzip(f, in_script_as_well = None):
    c=''
    if f[-3:] == '.gz' :
      system('gunzip '+f)
      if in_script_as_well or ( in_script_as_well == None and f[:3] != 'NEW' ):
        script.write('gunzip '+f+'\n')
      f=f[:-3]
      c='.gz'
    elif  f[-3:] == '.bz2' :
      print 'WARNING ! ',f,' is in BZIP2 format ! please fixme !'
    return (f,c)

  def script_zip(n,cn):
    if cn == '.gz' :
      script.write('minigzip -9 '+n+'\n')
    elif  cn == '.bz2' :
      print 'WARNING ! ',n,' is in BZIP2 format ! please fixme !'
      
  def delta_files(o,n):
    " compute delta of two files , and prepare the script consequently"
    if VERBOSE > 3 : print '   compute delta for  ',o,' and ',n
    nsize = os.stat(n)[ST_SIZE]
    osize = os.stat(o)[ST_SIZE]
    (o,co) = unzip(o)
    (n,cn) = unzip(n)
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    ## bsdiff uses memory equal to 17 times the size of oldfile
    try:
      a=os.statvfs(TD)
      freespace= a[0] * a[4]
    except a:
      if VERBOSE : print ' statvfs error ',a
      freespace = MAXMEMORY * 16
    if osize < MAXMEMORY / 17 and osize * 8 < freespace   :
      system('bsdiff  '+o+' '+n+' '+p)
      script.write('bspatch '+o+' '+n+' '+p+'\n')
    else:
      if VERBOSE > 2 : print '  fallback on xdelta instead of bsdiff' 
      system('xdelta delta -n -9 '+o+' '+n+' '+p)
      script.write('xdelta patch '+p+' '+o+' '+n+'\n')
    ## clean up
    script.write('rm '+p+' '+o+'\n')
    script_zip(n,cn)
    ## how did we fare ?
    deltasize = os.stat(p)[ST_SIZE]
    if VERBOSE > 1 :
      print '  delta is  %3.4f'  % ( deltasize * 100. /  nsize ) , '% of ',n
    #save it
    patch_append(pp)
    #clean up
    unlink(o)
    unlink(n)
    if DEBUG:
      pass #implement MD5

  def delta_data(o,n):
    (o,co) = unzip(o,False)
    (n,cn) = unzip(n)
    oldtar = tarfile.open(o, "r")
    oldnames = oldtar.getnames()
    
    newtar = tarfile.open(n, "r")
    for newtarinfo in newtar:
      name = newtarinfo.name
      if  ('/'+name) in  old_conffiles :
        if VERBOSE > 3 : print '   skip conffile ', name
      elif name in oldnames and  newtarinfo.isreg()  :
        oldtarinfo = oldtar.getmember(newtarinfo.name)
        if oldtarinfo.isreg() :
          oldtar.extract(oldtarinfo.name,"OLD/DATA" )
          system('cat OLD/DATA/'+name+' >> OLD/data_mega_cat')
          unlink('OLD/DATA/'+name)
          script.write('cat OLD/DATA/'+name+'  >> OLD/data_mega_cat ; rm OLD/DATA/'+name+'\n')
    delta_files('OLD/data_mega_cat',n)
    #clean up
    unlink(o)
    shutil.rmtree('OLD/DATA')
    script_zip(n,cn)
  ############ start computing deltas

    
  if not  FS:
    #this delta needs the old deb 
    script.write('#needs-old\n')

  #this following is actually
  #def delta_debs_using_old(old,new):

  ### start scanning the new deb  
  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append(s)

  #process all contents of old vs new .deb
  ar_list_old= list_ar('OLD.file')
  ar_list_new= list_ar('NEW.file')

  for name in ar_list_new :
    n = 'NEW/'+name
    system('ar p NEW.file '+name+' >> '+n)

    newsize = os.stat(n)[ST_SIZE]
    if VERBOSE > 1: print ' studying ' , name , ' of len ' , newsize
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 2: print '  ar line: ',repr(s)
    assert( s[:len(name)] == name and s[-2] == '`' and s[-1] == '\n' )
    append(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(newsize  ,1)
    if newsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if newsize < 128:      #file is too short to compute a delta,
      p=open(n)
      append( p.read(newsize))
      p.close()
      unlink(n)
    elif False and name[:11] == 'control.tar' :
      #TODO
      script.write('#old-control-tree\n')
    elif FS and name[:8] == 'data.tar'  :
      script.write('#old-data-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      delta_data(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif  FS or name not in ar_list_old :       #or it is not in old deb
      deltacount += 1
      pp=str(deltacount)
      p = 'PATCH/'+pp
      if VERBOSE > 3 : print '   including "',name,'" verbatim in patch'
      os.rename(n,p)
      patch_append(pp)
      script.write('cat '+p+' >> NEW.file ; rm '+p+'\n')      
    elif not FS:
      #file is long, and has old version ; lets compute a delta
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      script.write('ar p OLD.file '+name+' >> '+o+'\n')
      delta_files(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    else:
      raise
    #pad new deb
    if extrachar :
      append(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if s:
    if VERBOSE > 2: print '  ar leftover character: ',repr(s)
    append(s)

  if DEBUG:
    # add a MD5 check to script
    p=os.popen('md5sum NEW.file')
    a=p.readline()
    p.read()
    p.close
    a=de_n(a)
    if VERBOSE > 2 : print '   ',a
    script.write('echo "'+a+'" | md5sum -c > /dev/null')

  #script is done
  script.close()
  patchsize = os.stat('PATCH/patch.sh')[ST_SIZE]
  if  patchsize > newdebsize / 5 and patchsize > 512 :
    if VERBOSE > 2 : print '  patch.sh is quite large: using bzip2 '
    system('bzip2 -9  PATCH/patch.sh')
    patch_append('patch.sh.bz2')
  else:
    system('gzip -9 -n PATCH/patch.sh')  
    patch_append('patch.sh.gz')

  shutil.rmtree('OLD/CONTROL')
  shutil.rmtree('NEW/CONTROL')
    
  deltasize = os.stat(delta)[ST_SIZE]
  unlink('NEW.file')
  unlink('OLD.file')

  if VERBOSE:
    print ' deb delta is  %3.1f'  % \
          ( deltasize * 100. /  newdebsize ) ,    '% of deb'
    print ' that is, %dkB would be saved ' % (( newdebsize -deltasize  ) / 1024)
####################################
else:
  #unimplemented action
  assert(0)

#cleanup
os.chdir(TD)
rmdir('PATCH')
rmdir('OLD')
rmdir('NEW')
rmdir(TD)


##   a='ar qSc result.deb '
##   for o in arlist['NEW'] :
##     a=a+ ' ' + o + ' '

##     '!<arch>\n'

##   a='fakeroot sh -c "chown root.root * ; ' + a + ' " '
  
##   s.write()
  
##   S(' cd NEW ; ' + a)

##   ret=os.system('cmp NEW/result.deb '+newdeb )

##   if ret:
##     S('xdelta delta -n -9 '+newdeb+' NEW/result.deb ')
##   #S(['ar','qSc', 'temp.deb',]+ deltaparts)
##   #s.write('xdelta patch '+o+'.xdelta'+' ../OLD/'+o+' '+o+'\n')
  
##   def a(p,k,v):
##     if  p == None:
##       p = {}
##     if len(k) > 1  :
##       p[k[0]] = a(p.get(k[0]) , k[1:] ,v  )
##     else:
##       p[k[0]] = v
##       return p    

##     if '/' in s:
##       s=s.split('/')
##       if (len (s) == 2) :
##         ( a,  v ) = s
##         if '/' in s:
##           ....
##         params[ a  ] = v

##       elif (len (s) == 3) :
##         ( a, b, v ) = s
##         if a not in params :
##           params[a] ={}
##         params[ a ][b] = v
##       else:
##         print 'internal error on parm ', repr(s)


##     if False and DEBUG:
##       a=params['OLD/Package']
##       b='/var/lib/dpkg/info/' + a +'.list'
##       if os.path.exists(b ):
##         p=open(b)
##         s=p.read()
##         s=s.split('\n')
##         p.close()
##         for b in s :
##           if not ( b[1:] in oldnames ) :
##             print ' CASINO ',b
##         for b in oldnames : assert( '/'+b in s )
##       else:
##         print ' (package is not installed )',b
