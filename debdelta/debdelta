#!/usr/bin/python

doc={}
doc['delta']="""\
Usage: debdelta [ option...  ] fromfile tofile patchout
  Computes a delta from fromfile to tofile and writes it to patchout

Options:
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb   maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""


doc['deltas']="""\
Usage: debdeltas [ option...  ] deb_files
  Computes all missing deltas for Debian files deb_files

Options:
--dir DIR   force saving of deltas in this DIR
            (otherwise they go in the dir of the newer deb)
            if DIR ends in // , then the dirname of deb_file
            the  will be used as well
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb     maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""

## implement : --search    search in the directory of the above debs for older versions

doc['patch']="""\
Usage: debpatch [ option...  ] patchin  fromfile  tofile 
  Applies patchin to fromfile and produces a reconstructed  version of tofile.

(When using 'debpatch' and the old .deb is not available,
  use '/' for the fromfile.)

Usage: debpatch --info  patch
  Write info on patch.

Options:
"""

doc['delta-upgrade']="""\
Usage: debdelta-upgrade
  Downloads all deltas that may be used to 'apt-get upgrade', and apply them

Options:
--dir DIR   directory where to save results (default: /tmp/archive)
"""


doc_common="""
  -v      verbose (can be added multiple times)
  -k      keep temporary files
"""

## currently this is always true:
## -d      debug : add md5sums, check that  versions do match

minigzip='/usr/lib/debdelta/minigzip'


####################################################################

import sys , os , tempfile , string ,getopt , tarfile , shutil , time

from stat    import ST_SIZE
from os.path import abspath
from os      import unlink, rmdir
import shutil

################################################# main program, read options


MAXMEMORY = 1024 * 1024 * 50

MAX_DELTA_PERCENT = 50

DEBUG   = 1
VERBOSE = 0
KEEP    = False
INFO    = False
NEEDSOLD= False
DIR     = None

if os.path.dirname(sys.argv[0]) == '/usr/lib/apt/methods' :
  action = None
else:
  action=(os.path.basename(sys.argv[0]))[3:]
  actions =  ('delta','patch','deltas','delta-upgrade')
  
  if action not in actions:
    print 'wrong filename: should be "deb" + '+repr(actions)
    sys.exit(0)

  __doc__ = doc[action] + doc_common

  try: 
      ( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                                     ('help','info','needsold','dir=') )
  except getopt.GetoptError,a:
      sys.stderr.write(sys.argv[0] +': '+ str(a)+'\n')
      sys.exit(2)


  for  o , v  in  opts :
    if o == '-v' : VERBOSE += 1
    elif o == '-d' : DEBUG += 1
    elif o == '-k' : KEEP = True
    elif o == '--needsold' and action == 'delta' :  NEEDSOLD = True
    elif o == '-M' :    MAXMEMORY = 1024 * 1024 * int(v)
    elif o == '--info' and action == 'patch' : INFO = True
    elif o == '--dir'  :
      DIR = v
      if not os.path.isdir(DIR):
        print 'Error: --dir ',DIR,' does not exist.'
        sys.exit(3)
    elif o ==  '--help' or o ==  '-h':
      print __doc__
      sys.exit(0)
    else:
      print ' option ',o,'is unknown, try --help'
      sys.exit(1)

def dummy(): #otherwise the python mode for emacs fails to index my routines
  pass

if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a
  def rmtree(a):
    if VERBOSE : print ' would rm -r ',a
else:
  def rmtree(a):
    try:
      shutil.rmtree(a)
    except OSError,s:
      print ' Warning! when trying to remove ',repr(a),'got OSError',repr(str(s))

#################################################### various routines

def freespace(w):
  try:
    a=os.statvfs(w)
    freespace= a[0] * a[4]
  except:
    if VERBOSE : print ' statvfs error ',a
    freespace=None
  return freespace

dpkg_keeps_controls = (
  'conffiles','config','list','md5sums','postinst',
  'postrm','preinst','prerm','shlibs','templates')

def scan_control(p,params,prefix=None,script=None,stdout = None):
  if prefix == None:
    prefix = ''
  else:
    prefix += '/'
  a=p.readline()
  while a:
    a=de_n(a)
    if a[:4] in ('Pack','Vers','Arch','Stat','Inst','File'):
      if script : script.write('#'+prefix+a+'\n')
      if stdout : stdout.write(' ' + a)
      i=a.index(':')
      assert(a[i:i+2] == ': ')
      params[prefix+a[:i]] = a[i+2:]
    a=p.readline()

def make_parents(f):
  assert(f[0] == '/')
  s=f.split('/')
  d=''
  for a in s[:-1] :
    if a:
      d=d+'/'+a
      if not os.path.exists(d):
        os.mkdir(d)
  d=d+'/'+s[-1]
  return d

def de_n(a):
  if a and a[-1] ==  '\n' :
    a = a[:-1]
  return a

def de_bar(a):
  if a and a[:2] == './' :
    a=a[2:]
  if a and a[0] == '/' :
    a=a[1:]
  return a

def list_ar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list

def list_tar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('tar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list


def unpack(d,f,T):
  "unpacks 'ar' file f in directory d"
  assert(os.path.exists(f))
  cwd = os.getcwd()
  os.chdir(T+'/'+d)
  system('ar xo '+f)
  os.chdir(cwd)


ALLOWED = '<>()[]{}.,;:!_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r

from string import join

def version_mangle(v):
  if  ':' in v :
    return join(v.split(':'),'%3a')
  else:
    return v

def tempo():
  TD = abspath(tempfile.mkdtemp())
  for i in 'OLD','NEW','PATCH' :
    os.mkdir(TD+'/'+i)
  if  VERBOSE > 2 or KEEP :  print 'Temporary in '+TD
  return TD

##########


class DebDeltaError:
  def __init__(self,s):
    self.__str = s
  def __str__(self):
    return self.__str

def die(s=None):
  #if s : sys.stderr.write(s+'\n')
  raise DebDeltaError,s

  
def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if ret == 2:
    return KeyboardInterrupt
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    die('Error , non zero return status '+str(ret)+' for command "'+a+'"')

def check_deb(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    die('Error: '+f+ 'does not seem to be a Debian package ')
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    die('Error: '+f+ ' does not seem to be a Debian delta ')
  p.close()

#################################################################### apply patch

def do_patch(delta,olddeb,newdeb,TD):  
  delta=abspath(delta)
  if newdeb:
    newdeb=abspath(newdeb)
  if olddeb != '/':
    olddeb=abspath(olddeb)
    
  start_sec = time.time()
  
  check_diff(delta)

  if INFO:
    os.chdir(TD+'/PATCH')
    system('ar x  '+delta+' patch.sh patch.sh.gz patch.sh.bz2 2> /dev/null')
  else:    
    if olddeb != '/':
      check_deb(olddeb)
    if  newdeb and os.path.exists(newdeb) :
      os.rename(newdeb,newdeb+'~')
    unpack ('PATCH',delta,TD)
  #from here on, we live in the temp dir
  os.chdir(TD)
    
  os.symlink(minigzip,'minigzip')

  if os.path.exists('PATCH/patch.sh.gz'):
    system('gunzip PATCH/patch.sh.gz')
  elif os.path.exists('PATCH/patch.sh.bz2'):
    system('bunzip2 PATCH/patch.sh.bz2')  

  #lets scan parameters, to see what it does and what it requires
  params={}
  if not os.path.isfile('PATCH/patch.sh'):
    die('Error. File '+delta+' is not a debdelta file.')
  p=open('PATCH/patch.sh')
  s=p.readline()#skip #!/bin/sh
  s=p.readline()
  while s :
    if s[0] == '#' :
      s=de_n(s)[1:]
      if VERBOSE > 2 or (VERBOSE and action != 'deltas' and \
                         action != 'delta-upgrade' ) or INFO :
        print ' info: ',s
      if ':' in s:
        i=s.index(':')  
        params[s[:i]] = s[i+2:]
      else:
        params[s] = True
    s=p.readline()
  p.close()

  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      die(' Not enough disk space (%dkB) for applying delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) )

  ## really we will apply the patch
  if not INFO:
    #unpack the old control structure, if available
    os.mkdir(TD+'/OLD/CONTROL')
    if olddeb != '/' :
      os.symlink(olddeb,TD+'/OLD.file')
      #unpack control.tar.gz
      system('ar p OLD.file control.tar.gz | tar -x -z -f - -C OLD/CONTROL')
    #then we check for the conformance
    if  DEBUG:
      dpkg_params={}
      b=params['OLD/Package']
      if olddeb == '/' :
        p=os.popen('env -i dpkg -s '+b)
      else:        
        p=open('OLD/CONTROL/control')
      scan_control(p,dpkg_params,'OLD')
      p.close()
      if  olddeb == '/' :
        if 'OLD/Status' not in dpkg_params:
          die('Error: package %s is not known to dpkg.' % b)
        if  dpkg_params['OLD/Status'] != 'install ok installed' :
          die('Error: package %s is not installed, status is %s.'
            % ( b , dpkg_params['OLD/Status'] ) )
      for a in  params:
        if a[:3] == 'OLD' and a != 'OLD/Installed-Size':
          if a not in dpkg_params:
            die('Error parsing old control file , parameter %s not found' % a)
          elif  params[a] != dpkg_params[a] :
            die( 'Error : in debdelta , '+a+' = ' +params[a] +\
                 '\nin old/installed deb, '+a+' = ' +dpkg_params[a])

    ###see into parameters: the patch may need extra info
    #as a whole unpack of 'ar' of the old deb
    if 'unpack-old' in params:
      if olddeb == '/':
        die('This patch needs the old version Debian package')
      unpack ('OLD',olddeb,TD)

    if 'needs-old' in params and olddeb == '/':
      die('This patch needs the old version Debian package')

    if 'old-data-tree' in params :
      os.mkdir(TD+'/OLD/DATA')
      if olddeb == '/':
        pa=params['OLD/Package']
        s=[]
        p=os.popen('env -i dpkg -L '+pa)
        a=p.readline()
        while a:
          a=de_n(a)
          if s and a[:11] == 'diverted by':
            orig,divert=s.pop()
            #support diversions
            i = a.index(':')
            divert = a[i+2:]
            s.append( (orig,divert) )
          else:
            s.append( (a,a) )
          a=p.readline()
        p.close()        
        for orig,divert in s:          
          if os.path.isfile(divert) and not os.path.islink(divert) :            
            a=make_parents(TD+'/OLD/DATA'+orig)
            if VERBOSE > 3 : print '   symlinking ',divert,' to ',a
            os.symlink(divert, a)
          else:
            if VERBOSE > 4 : print '    not symlinking ',divert,' to ',orig
      else:
        system('ar p OLD.file data.tar.gz | tar -x -z -f - -C OLD/DATA')


    if 'old-control-tree' in params and olddeb == '/':      
      p=params['OLD/Package']
      for  b in dpkg_keeps_controls :
        a='/var/lib/dpkg/info/' + p +'.'+b
        if os.path.exists(a ):
          os.symlink(a,'OLD/CONTROL/'+b)

    ##then , really execute the patch
    a=''
    if VERBOSE >= 4 : a = '-v'
    system('/bin/sh -e '+a+' PATCH/patch.sh')
    if newdeb:
      shutil.move('NEW.file',newdeb)

    if VERBOSE :
      if newdeb:
        debsize = os.stat(newdeb)[ST_SIZE]
      else:
        debsize = os.stat(olddeb)[ST_SIZE]
      end_sec = time.time()
      a=(end_sec - start_sec)
      print ' patching time: %dsec, speed:  %dkB per second ' % (a,(debsize / 1024 /  (a+1)))

##################################################### compute delta

def do_delta(olddeb,newdeb,delta,TD):
  start_sec = time.time()

  olddeb=abspath(olddeb)
  check_deb(olddeb)
  os.symlink(olddeb,TD+'/OLD.file')

  newdeb=abspath(newdeb)
  check_deb(newdeb)
  os.symlink(newdeb,TD+'/NEW.file')
  newdebsize = os.stat(newdeb)[ST_SIZE]

  free=freespace(TD)
  if free and free < newdebsize * 2:
    die('Error: not enough disk space in '+TD)

  delta=abspath(delta)
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  #from here on, we live in the temp dir
  os.chdir(TD)

  #counter for numbered files
  global deltacount
  deltacount = 0 

  #start writing script 
  script=open('PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')


  def append(s):
    'appends some data to NEW.file'
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")

  ##### unpack control.tar.gz, scan control, write  parameters
  params={}
  for o in 'OLD', 'NEW' :
      os.mkdir(TD+'/'+o+'/CONTROL')
      #unpack control.tar.gz
      system('ar p '+o+'.file control.tar.gz | tar -x -z -f - -C '+o+'/CONTROL')
      ## scan control
      if  VERBOSE > 1 :
        print o
        s=sys.stdout
      else:
        s=None
      p=open(TD+'/'+o+'/CONTROL/control') 
      scan_control(p,params,o,script,s)
      p.close()
      if s: print
      del s,p

  # uses MD5 to detect identical files (even when renamed)
  data_identical={}
  if os.path.exists(TD+'/NEW/CONTROL/md5sums') and \
     os.path.exists(TD+'/OLD/CONTROL/md5sums') :
    f=open(TD+'/OLD/CONTROL/md5sums')
    do={}
    a=de_n(f.readline())
    while a:
      m , n = a[:32] ,  de_bar( a[34:] )
      do[ m ] = n
      a=de_n(f.readline())
    f.close()
    f=open(TD+'/NEW/CONTROL/md5sums')
    dn={}
    mul={}
    us={}
    r=None
    a=de_n(f.readline())
    while a:
      m , n = a[:32] ,  de_bar( a[34:] )
      if m in do:
         #sometimes there are multiple occurences of the same file...
         # ( as in    tetex-doc_3.0-18_all.deb    )
         r=do[m]
         if r in us:
           mul[r] = True
         us[ r ] = True
         dn[ n ] = r
      a=de_n(f.readline())
    f.close()
    for n in dn:
      data_identical[ n ] = ( dn[ n ], mul.get( dn[ n ] ) )
    del f,dn,do,a,mul,n,m,r,us

    
  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)  
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      die(' Not enough disk space (%dkB) for creating delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) )

  ## check for conffiles 
  a=TD+'/OLD/CONTROL/conffiles'
  if os.path.exists(a):
    p=open(a)
    old_conffiles=p.read().split('\n')
    p.close()
  else:
    old_conffiles=()
  ############### some routines  to prepare delta of two files

  def patch_append(f):
    os.chdir(TD+'/PATCH')
    system(['ar','qSc', delta,f])
    unlink(f)
    os.chdir(TD)

  def verbatim(f):
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    if VERBOSE > 3 : print '   including "',name,'" verbatim in patch'
    os.rename(f,p)
    patch_append(pp)
    return p
      
  def unzip(f, in_script_as_well = None):
    c=''
    if f[-3:] == '.gz' :
      system('gunzip '+f)
      if in_script_as_well or ( in_script_as_well == None and f[:3] != 'NEW' ):
        script.write('gunzip '+f+'\n')
      f=f[:-3]
      c='.gz'
    elif  f[-3:] == '.bz2' :
      print 'WARNING ! ',f,' is in BZIP2 format ! please fixme !'
    return (f,c)

  def script_zip(n,cn):
    if cn == '.gz' :
      script.write('./minigzip -9 '+n+'\n')
    elif  cn == '.bz2' :
      print 'WARNING ! ',n,' is in BZIP2 format ! please fixme !'
      
  def delta_files(o,n):
    " compute delta of two files , and prepare the script consequently"
    if VERBOSE > 3 : print '   compute delta for  ',o,' and ',n
    nsize = os.stat(n)[ST_SIZE]
    osize = os.stat(o)[ST_SIZE]
    (o,co) = unzip(o)
    (n,cn) = unzip(n)
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    ## according to the man page,
    ## bsdiff uses memory equal to 17 times the size of oldfile
    ## but , in my experiments, this number is more like 12
    free=freespace(TD)
    if free == None :
      free = MAXMEMORY * 16
    if ( osize < (MAXMEMORY / 12)) and (osize < (free / 8)) :
      system('bsdiff  '+o+' '+n+' '+p)
      script.write('bspatch '+o+' '+n+' '+p+'\n')
    else:
      if VERBOSE > 3 : print '   fallback on xdelta instead of bsdiff' 
      system('xdelta delta -n -9 '+o+' '+n+' '+p)
      script.write('xdelta patch '+p+' '+o+' '+n+'\n')
    ## clean up
    script.write('rm '+p+' '+o+'\n')
    script_zip(n,cn)
    ## how did we fare ?
    deltasize = os.stat(p)[ST_SIZE]
    if VERBOSE > 2 :
      print '  delta is  %3.4f'  % ( deltasize * 100. /  nsize ) , '% of ',n
    #save it
    patch_append(pp)
    #clean up
    unlink(o)
    unlink(n)
    if DEBUG:
      pass #implement MD5

  def delta_tar(o,n,w,skip=(),renames={}):
    " compute delta of two tar files, and prepare the script consequently"
    (o,co) = unzip(o,False)
    (n,cn) = unzip(n)
    oldtar = tarfile.open(o, "r")
    oldnames = oldtar.getnames() #map( de_bar , oldtar.getnames() )
    oldused={}
    if VERBOSE > 3 : print '   scanning ',n
    newtar = tarfile.open(n, "r")
    for newtarinfo in newtar:
      name = de_bar( newtarinfo.name )
      if not newtarinfo.isreg():
        if VERBOSE > 4 : print '  not regular in new : ', name
        continue
      multiple = False
      if name in renames:
        ( oldname , multiple ) = renames[name]
        if VERBOSE >3 : print '   identical!  ', oldname, name, multiple
      else:
        oldname = name

      if   oldname in skip :
        if VERBOSE > 3 : print '   skip using old file ', name
        continue
      
      if oldname in oldnames  :
        oldtarinfo = oldtar.getmember(oldname)        
        assert( oldtarinfo.name == oldname )
        if oldtarinfo.isreg() :
          if VERBOSE > 4 : print '  use old file ', oldname
          oldused[oldname] = name
          del name
          oldtar.extract(oldname,"OLD/"+w )
          system("cat 'OLD/"+w+"/"+oldname+"' >> OLD/mega_cat")
          unlink('OLD/'+w+'/'+oldname)          
          script.write("cat 'OLD/"+w+"/"+oldname+"'  >> OLD/mega_cat\n")
          if not multiple:
            script.write("rm 'OLD/"+w+"/"+oldname+"'\n")
        elif VERBOSE > 4 : print '  not regular in old : ', name
      elif VERBOSE > 4 : print '  not present in old : ', name

    #there may be files that have been renamed and edited...
    for oldname in oldnames :
      if (oldname not in oldused) and  (oldname not in skip) :
        oldtarinfo = oldtar.getmember(oldname)
        assert( oldtarinfo.name == oldname )
        if oldtarinfo.isreg() :
          if VERBOSE > 4 : print ' provide also old file ', oldname
          oldtar.extract(oldname,"OLD/"+w )
          system("cat 'OLD/"+w+"/"+oldname+"' >> OLD/mega_cat")
          unlink('OLD/'+w+'/'+oldname)
          script.write("cat 'OLD/"+w+"/"+oldname+"'  >> OLD/mega_cat ; rm 'OLD/"+w+"/"+oldname+"'\n")
    
    if os.path.exists('OLD/mega_cat'):
      rmtree('OLD/'+w)
      delta_files('OLD/mega_cat',n)
      if os.path.exists('OLD/mega_cat'):
        # if -k is given, still we need to delete it...
        os.unlink('OLD/mega_cat')
    else:
      p=verbatim(n)
      script.write('mv '+p+' '+n+ '\n')
    unlink(o)
    script_zip(n,cn)
  ############ start computing deltas

    
  if NEEDSOLD :
    #this delta needs the old deb 
    script.write('#needs-old\n')

  #this following is actually
  #def delta_debs_using_old(old,new):

  ### start scanning the new deb  
  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append(s)

  #process all contents of old vs new .deb
  ar_list_old= list_ar('OLD.file')
  ar_list_new= list_ar('NEW.file')

  for name in ar_list_new :
    n = 'NEW/'+name
    system('ar p NEW.file '+name+' >> '+n)

    newsize = os.stat(n)[ST_SIZE]
    if VERBOSE > 2: print ' studying ' , name , ' of len ' , newsize
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 4: print '  ar line: ',repr(s)
    assert( s[:len(name)] == name and s[-2] == '`' and s[-1] == '\n' )
    append(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(newsize  ,1)
    if newsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if newsize < 128:      #file is too short to compute a delta,
      p=open(n)
      append( p.read(newsize))
      p.close()
      unlink(n)
    elif  name[:11] == 'control.tar' :
      #(mm this is almost useless, just saves a few bytes)
      script.write('#old-control-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      ##avoid using strange files that dpkg may not install in /var...info/
      skip=[]
      for a in os.listdir('OLD/CONTROL') :
        if a not in dpkg_keeps_controls:
          skip.append(a)
      #delta it
      delta_tar(o,n,'CONTROL',skip)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif not NEEDSOLD and name[:8] == 'data.tar'  :
      script.write('#old-data-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      delta_tar(o,n,'DATA',old_conffiles,data_identical)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif  not NEEDSOLD  or name not in ar_list_old :   #or it is not in old deb
      p=verbatim(n)
      script.write('cat '+p+' >> NEW.file ; rm '+p+'\n')
    elif  NEEDSOLD :
      #file is long, and has old version ; lets compute a delta
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      script.write('ar p OLD.file '+name+' >> '+o+'\n')
      delta_files(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    else:
      die('internal error')
    #pad new deb
    if extrachar :
      append(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if s:
    if VERBOSE > 2: print '  ar leftover character: ',repr(s)
    append(s)

  if DEBUG:
    # add a MD5 check to script
    p=os.popen('md5sum NEW.file')
    a=p.readline()
    p.read()
    p.close
    a=de_n(a)
    if VERBOSE > 2 : print '   ',a
    script.write('echo "'+a+'" | md5sum -c > /dev/null')

  #script is done
  script.close()
  patchsize = os.stat('PATCH/patch.sh')[ST_SIZE]
  if  patchsize > newdebsize / 5 and patchsize > 512 :
    if VERBOSE > 2 : print '  patch.sh is quite large: using bzip2 '
    system('bzip2 -9  PATCH/patch.sh')
    patch_append('patch.sh.bz2')
  else:
    system('gzip -9 -n PATCH/patch.sh')  
    patch_append('patch.sh.gz')

  deltasize = os.stat(delta)[ST_SIZE]
  
  elaps =  time.time() - start_sec
  percent =  deltasize * 100. /  newdebsize 
  if VERBOSE:
    print ' deb delta is  %3.1f%% of deb ; that is, %dkB would be saved' \
          % ( percent , (( newdebsize -deltasize ) / 1024) )
    if VERBOSE :
      print '  delta time: %dsec, speed: %dkB per second ' %  \
            (elaps, newdebsize / 1024 / (elaps+1))
  return (delta, percent, elaps)


##################################################### compute many deltas

def do_deltas(argv):
  original_cwd = os.getcwd()
  try:
    from apt import VersionCompare
  except ImportError:
    import apt_pkg
    apt_pkg.InitSystem()
    from apt_pkg import VersionCompare
  debs=[]
  for i in argv:
    debs.append(i)

  info_by_pack_arch={}
  info_by_file={}

  def scan_deb(f):
      info_by_file[f]={}
      p=os.popen('ar p '+f+' control.tar.gz | tar -x -z -f - -O ./control')
      scan_control(p,info_by_file[f])
      p.close()
      info_by_file[f]['File'] = f
      pa=info_by_file[f]['Package']
      ar=info_by_file[f]['Architecture']
      if  (pa,ar) not in  info_by_pack_arch :
         info_by_pack_arch[ (pa,ar) ]=[]
      info_by_pack_arch[ (pa,ar) ].append( info_by_file[f] )

  for f in debs:
    if os.path.isfile(f):
      scan_deb(f)
    elif  os.path.isdir(f) :
      for a in  filter( lambda a : a[-4:] == '.deb' ,os.listdir(f) ) :
        scan_deb(f+'/'+a)
    else:
      print 'Warning: '+f+' is not a regular file or a directory.'
      
  def order_by_version(a,b):
    return VersionCompare( a['Version'] , b['Version']  )
  
  for pa,ar in info_by_pack_arch :
    l= len( info_by_pack_arch[ (pa,ar) ] )

    if l > 1 :
      info_by_pack_arch[ (pa,ar) ].sort(order_by_version)

      l -= 1
      while l>0:
        os.chdir(original_cwd)
        l -= 1
        old=info_by_pack_arch[ (pa,ar) ][l]
        new=info_by_pack_arch[ (pa,ar) ][l+1]

        newdebsize=os.stat(new['File'])[ST_SIZE]
        #very small packages cannot be effectively delta-ed
        if newdebsize <= 4 * 1024 :
          #this actually affects 1 every 60 packages in the archives
          if VERBOSE > 1:     print 'Skip , too small: ', new['File']
          break
        
        assert( old['Package'] == pa and pa == new['Package'] )
        deltabasename = pa +'_'+  version_mangle(old['Version']) +\
                        '_'+ version_mangle(new['Version']) +'_'+ar+'.debdelta'
        if DIR:
          if DIR[-2:] == '//' :
            a=DIR+'/'+os.path.dirname(new['File'])+'/'+deltabasename
            delta=make_parents(a)
          else:
            delta = DIR+'/'+deltabasename
        else:
          delta = os.path.dirname(new['File']) + '/'+deltabasename
        if os.path.exists(delta):
          if VERBOSE > 2:     print 'Skip , already exists: ',delta
          break
        if os.path.exists(delta+'-too-big'):
          if VERBOSE > 2:     print 'Skip , tried and too big: ',delta
          break

        free=freespace(os.path.dirname(delta))
        if free and free < newdebsize /2 + 1024 :
          if VERBOSE : print 'Not enough disk space for storing ',delta
          break
        
        if VERBOSE: print 'Creating :',delta
        ret= None
        T=tempo()          
        try:
          ret=do_delta(old['File'],new['File'], delta,T)
        except KeyboardInterrupt:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          rmtree(T)
          raise
        except DebDeltaError,s:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          if not VERBOSE: print 'Creating: ',delta
          print ' Creation of delta failed, reason: ',str(s)
        except:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          raise
        os.chdir(original_cwd)
        rmtree(T)

        if ret and MAX_DELTA_PERCENT:
          if ret[1] > MAX_DELTA_PERCENT and os.stat(delta)[ST_SIZE] >= 4*1024 :
            os.unlink(delta)
            if VERBOSE : print ' Warning, too big!'
            p=open(delta+'-too-big','w')
            p.close()
            ret = None

        if DEBUG > 1 and ret :
          T=tempo()
          try:
            do_patch(delta,old['File'],None ,T)
          except KeyboardInterrupt:
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
            rmtree(T)
            raise
          except DebDeltaError,s:
            print ' Error: testing of delta failed: ',str(s)
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
          except:
            print " Unexpected error while testing delta:", sys.exc_info()[0]
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
            rmtree(T)
            raise
          os.chdir(original_cwd)
          if os.path.exists(T):
            rmtree(T)

################################################# main program, do stuff

if action == 'patch':
  if INFO  :
    if  len(argv) > 1 and VERBOSE :
      print '(printing info - extra arguments are ignored)'
    elif  len(argv) == 0  :
      print ' need a  filename ;  try --help'
      sys.exit(1)
  elif len(argv) != 3 :  
    print ' need 3 filenames ;  try --help'
    sys.exit(1)
  
  newdeb=abspath(argv[2])
  T=tempo()
  try:
    do_patch(abspath(argv[0]), abspath(argv[1]), newdeb ,T)
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    rmtree(T)
    sys.exit(2)
  except KeyboardInterrupt:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
  except:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    raise
  rmtree(T)
  
elif action == 'delta' :
  if len(argv) != 3 :  
    print ' need 3 filenames ;  try --help'
    sys.exit(1)
    
  T=tempo()
  delta=abspath(argv[2])
  try:
    do_delta(abspath(argv[0]), abspath(argv[1]), delta ,T)  
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    rmtree(T)
    if os.path.exists(delta):
      os.unlink(delta)
    sys.exit(2)
  except KeyboardInterrupt:
    if os.path.exists(delta):
      os.unlink(delta)
  except:
    if os.path.exists(delta):
      os.unlink(delta)
    raise
  rmtree(T)
  
elif action == 'deltas' :
  try:
    do_deltas(argv)
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    sys.exit(2)

  
##################################################### delta-upgrade
    
def delta_upgrade(DIR):
  import  thread , pickle

  original_cwd = os.getcwd() 
  import httplib
  conn=httplib.HTTPConnection("tonelli.sns.it")
  delta_http_base='/mirror/debian-deltas'

  import  apt, apt_pkg
  apt_pkg.init()

  cache=apt.Cache()
  cache.upgrade()

  if DIR == None:
    DIR='/tmp/archives'
  if not os.path.exists(DIR):    
    os.mkdir(DIR)

  print 'Recreated debs are saved in ',DIR
  start_sec = time.time()
  len_newdebs=0
  len_deltas=0

  (qout,qin)=os.pipe()
  #qoutf=os.fdopen(qout)
  def thread_do_patch(qout,threads):
      if VERBOSE>=2 : print ' Patching thread started. '
      while 1:
        s=os.read(qout,1)
        c=''
        while s != '\t' :
          c+=s
          s=os.read(qout,1)
        if c == '\t' or c == '': break
        (name,tmp_delta , newdeb) = pickle.loads(c)      
        if VERBOSE>=2 : print ' Now patching for: ',name
        # my fault...  do_patch() wants its own CWD!
        pid=os.fork()
        if pid == 0:
          T=tempo()
          try:
            ret=do_patch(tmp_delta,'/',newdeb ,T)
            if VERBOSE : print '   for ',name
          except DebDeltaError,s:
            print ' Error: applying of delta for ',name,'failed: ',str(s)
            if os.path.exists(newdeb):
              os.unlink(newdeb)
          except:
            print " Error while applying delta for ",name,":",sys.exc_info()
            if os.path.exists(newdeb):
              os.unlink(newdeb)
          if os.path.exists(tmp_delta):
            unlink(tmp_delta)
          os.chdir(original_cwd)
          if os.path.exists(T):
            rmtree(T)
        else:
          os.waitpid(pid,0)
        global len_newdebs
        if len_newdebs != None and os.path.exists(newdeb):
          len_newdebs += os.stat(newdeb)[ST_SIZE]
      threads.pop()
      if VERBOSE>=2 : print ' Patching thread ended , bye bye. '
      return

  threads=[]
  threads.append(thread.start_new_thread(thread_do_patch  , (qout,threads) ) )

  for p in cache :
    if p.isInstalled and  p.markedUpgrade \
           and p.candidateOrigin[0].origin == 'Debian':

      ## FIXME : how do I get the URI and/or architecture out of python-apt ??
      #if p.sourcePackageName[:3] == 'lib':
      #  b=p.sourcePackageName[:4]
      #else:
      #  b=p.sourcePackageName[0]
      #c=p.candidateOrigin[0].component
      ## rely on usual pool structure....
      #u=c+'/'+b+'/'+p.sourcePackageName
      ##this sucks... it is so slow..., but it works
      dpkg_params={}
      pip=os.popen('env -i dpkg -p '+p.name)
      scan_control(pip,dpkg_params)
      pip.close()
      arch=dpkg_params['Architecture']
      deb_uri=dpkg_params['Filename']
      assert(dpkg_params['Version'] == p.installedVersion )


      newdeb=p.name+'_'+version_mangle(p.candidateVersion)+'_'+arch+'.deb'
      if os.path.exists(DIR+'/'+newdeb) or \
             os.path.exists('/var/cache/apt/archives/'+newdeb):
        if VERBOSE: print  'Already downloaded: ',newdeb
        continue

      if VERBOSE:
        print 'Looking for a delta for %s from %s to %s ' % \
              ( p.name, p.installedVersion, p.candidateVersion )

      newdeb = DIR+'/'+newdeb

      #delta name
      delta_name=p.name+'_'+version_mangle(p.installedVersion)+\
                  '_'+ version_mangle(p.candidateVersion)+'_'+\
                  arch+'.debdelta'

      uri=delta_http_base+'/'+os.path.dirname(deb_uri)+'/'+delta_name

      if VERBOSE > 2: print ' uri ',uri

      conn.connect()
      conn.request("GET", uri)
      r = conn.getresponse()
      if r.status != 200:
        if VERBOSE: print '  delta is not available',repr(r.status), r.reason
        data1 = r.read()
        continue
      (delta_fd, tmp_delta) = tempfile.mkstemp()
      j=0
      s=r.read(1024)
      while s:
        os.write(delta_fd,s)
        j += 1
        sys.stderr.write(" %5d kB for %s \r" % ( j , delta_name))
        s=r.read(1024)        
      os.close(delta_fd)
      conn.close()
      sys.stderr.write(" " * 70 + '\r')

      #append to queue
      c=pickle.dumps(  (p.name,tmp_delta,newdeb) )
      os.write(qin, c + '\t' )

  #terminate queue
  os.write(qin,'\t\t\t')
  if VERBOSE>=2 : print ' Downloading done, waiting for patching thread. '
  while threads:
    time.sleep(0.2)

  elaps =  time.time() - start_sec
  if VERBOSE:
    print 'Delta-upgrade download and patch time: %dsec; virtual speed: %dkB per second.' %  \
          (elaps, len_newdebs / 1024 / (elaps+1)) 
##################################################### apt method
### still work in progress
if action == 'delta-upgrade':
  import warnings
  warnings.simplefilter("ignore",FutureWarning)
  delta_upgrade(DIR)
      
if  os.path.dirname(sys.argv[0]) == '/usr/lib/apt/methods' :
  import os,sys, select, fcntl, apt, thread, threading, time

  apt_cache=apt.Cache()
  
  log=open('/tmp/log','a')
  log.write('  --- here we go\n')
  
  ( hi, ho , he) = os.popen3('/usr/lib/apt/methods/http.distrib','b',2)

  nthreads=3

  class cheat_apt_gen:
    def __init__(self):
      self.uri=None
      self.filename=None
      self.acquire=False
    def process(self,cmd):
      if self.uri:
        self.filename=cmd[10:-1]
        log.write(' download %s for %s\n' % (repr(self.uri),repr(self.filename)))
        self.uri=None
        self.filename=None
        self.acquire=False
        return cmd
      elif self.acquire:
        self.uri=cmd[5:-1]
        return cmd
      elif cmd[:3] == '600' :
        self.acquire=True
      else:
        return cmd
  
  def copyin():
    bufin=''
    while 1:
      #print ' o'
      s=os.read(ho.fileno(),1)
      bufin += s
      if log and bufin and (s == '' or s == '\n') :
        log.write( ' meth ' +repr(bufin)+'\n' )
        bufin=''
      if s == '':
        thread.interrupt_main(   )
        global nthreads
        if nthreads:
          nthreads-=1
        #log.write( ' in closed \n' )
        #return
      os.write(1,s)


  def copyerr():
    buferr=''
    while 1:
      s=os.read(he.fileno(),1)
      buferr += s
      if log and buferr and (s == '' or s == '\n') :
        log.write( ' err ' +repr(buferr)+'\n' )
        buferr=''
      if s == '':
        thread.interrupt_main(   )
        global nthreads
        if nthreads:
          nthreads-=1
        log.write( ' err closed \n' )
        #return
      os.write(2,s)

  def copyout():
    gen=cheat_apt_gen()
    bufout=''
    while 1:
      s=os.read(0,1)
      bufout += s
      if log and bufout and (s == '' or s == '\n') :
        log.write( ' apt ' +repr(bufout)+'\n' )

        bufout=gen.process(bufout) 
        
        bufout=''
      if s == '':
        thread.interrupt_main()
        global nthreads
        if nthreads:
          nthreads-=1
        #log.write( ' out closed \n' )
        #return
      os.write(hi.fileno(),(s))

        
  tin=thread.start_new_thread(copyin,())
  tout=thread.start_new_thread(copyout,())
  terr=thread.start_new_thread(copyerr,())
  while nthreads>0 :
    log.write( ' nthreads %d \n' % nthreads )
    try:
      while nthreads>0 :
        time.sleep(1)      
    except KeyboardInterrupt:
      pass
  sys.exit(0)

