#!/usr/bin/python

doc={}
doc['delta']="""\
Usage: debdelta [ option...  ] fromfile tofile patchout
  Computes a delta from fromfile to tofile and writes it to patchout

Options:
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb   maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""


doc['deltas']="""\
Usage: debdeltas [ option...  ]  [deb_files and dirs]
  Computes all missing deltas for Debian files.
  It orders by version number and produce deltas to the newest version

Options:
--dir DIR   force saving of deltas in this DIR
            (otherwise they go in the dir of the newer deb)
            if DIR ends in // , then the dirname of deb_file
            the  will be used as well
 -n N       how many deltas to produce for each deb (default 1)
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb     maximum memory (to decide if using 'bsdiff' or 'xdelta',
            and how much memory to use for 'xdelta' )
"""

## implement : --search    search in the directory of the above debs for older versions

doc['patch']="""\
Usage: debpatch [ option...  ] patchin  fromfile  tofile 
  Applies patchin to fromfile and produces a reconstructed  version of tofile.

(When using 'debpatch' and the old .deb is not available,
  use '/' for the fromfile.)

Usage: debpatch --info  patch
  Write info on patch.

Options:
"""

doc['delta-upgrade']="""\
Usage: debdelta-upgrade
  Downloads all deltas that may be used to 'apt-get upgrade', and apply them

Options:
--dir DIR   directory where to save results (default: /tmp/archive)
"""


doc_common="""
  -v      verbose (can be added multiple times)
  -k      keep temporary files
"""

## currently this is always true:
## -d      debug : add md5sums, check that  versions do match

minigzip='/usr/lib/debdelta/minigzip'


####################################################################

import sys , os , tempfile , string ,getopt , tarfile , shutil , time

from stat    import ST_SIZE, ST_MODE, S_IMODE, S_IRUSR, S_IWUSR, S_IXUSR 
from os.path import abspath

from types import StringType, FunctionType, TupleType, ListType

import shutil

################################################# main program, read options


DELTA_URL="http://tonelli.sns.it/mirror/debian-deltas"

#target of: maximum memory that bsdiff will use
MAXMEMORY = 1024 * 1024 * 50

#this is +-10% , depending on the package size
MAX_DELTA_PERCENT = 70

N_DELTAS= 1

#seems that 'xdelta' is buggy on 64bit and different-endian machines
ALLOW_XDELTA = False

DEBUG   = 1
VERBOSE = 0
KEEP    = False
INFO    = False
NEEDSOLD= False
DIR     = None
AVOID   = None



if os.path.dirname(sys.argv[0]) == '/usr/lib/apt/methods' :
  action = None
else:
  action=(os.path.basename(sys.argv[0]))[3:]
  actions =  ('delta','patch','deltas','delta-upgrade')
  
  if action not in actions:
    print 'wrong filename: should be "deb" + '+repr(actions)
    sys.exit(0)

  __doc__ = doc[action] + doc_common

  try: 
    ( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:n:' ,
                 ('help','info','needsold','allow-xdelta','dir=','avoid=') )
  except getopt.GetoptError,a:
      sys.stderr.write(sys.argv[0] +': '+ str(a)+'\n')
      sys.exit(2)

  for  o , v  in  opts :
    if o == '-v' : VERBOSE += 1
    elif o == '-d' : DEBUG += 1
    elif o == '-k' : KEEP = True
    elif o == '--allow-xdelta' :  ALLOW_XDELTA = True
    elif o == '--needsold' :  NEEDSOLD = True
    elif o == '-M' :
      if int(v) <= 1:
        print 'Error: "-M ',int(v),'" is too small.'
        sys.exit(1)
      if int(v) <= 12:
        print 'Warning: "-M ',int(v),'" is quite small.'
      MAXMEMORY = 1024 * 1024 * int(v)
    elif o == '-n' :
      N_DELTAS = int(v)
      if N_DELTAS <= 0:
        print 'Error: -n ',v,' is negative or zero.'
        sys.exit(3) 
    elif o == '--info' and action == 'patch' : INFO = True
    elif o == '--avoid'  :
      AVOID = v
      if not os.path.isfile(AVOID):
        print 'Error: --avoid ',AVOID,' does not exist.'
        sys.exit(3)
    elif o == '--dir'  :
      DIR = v
      if not os.path.isdir(DIR):
        print 'Error: --dir ',DIR,' does not exist.'
        sys.exit(3)
    elif o ==  '--help' or o ==  '-h':
      print __doc__
      sys.exit(0)
    else:
      print ' option ',o,'is unknown, try --help'
      sys.exit(1)

def dummy(): #otherwise the python mode for emacs fails to index my routines
  pass

if KEEP:
  def unlink(a):
    if VERBOSE > 4: print ' would unlink ',a
  def rmdir(a):
    if VERBOSE > 4: print ' would rmdir ',a
  def rmtree(a):
    if VERBOSE > 4: print ' would rm -r ',a
else:
  def __wrap__(a,cmd):
    t=os.getenv('TMPDIR')
    if t == None:
      t='/tmp'
    c=cmd.__name__+"("+a+")"
    if a[ : len(t)+4 ] != t+'/tmp' :
      raise DebDeltaError,'Internal error! refuse to  '+c
    try:
      cmd(a)
    except OSError,s:
      print ' Warning! when trying to ',repr(c),'got OSError',repr(str(s))
      if DEBUG > 2 : raise

  def unlink(a):
    return __wrap__(a,os.unlink)
  def rmdir(a):
    return __wrap__(a,os.rmdir)
  def rmtree(a):
    return __wrap__(a,shutil.rmtree)

#################################################### various routines

def freespace(w):
  assert(os.path.exists(w))
  try:
    a=os.statvfs(w)
    freespace= a[0] * a[4]
  except:
    if VERBOSE : print ' statvfs error ',a
    freespace=None
  return freespace

dpkg_keeps_controls = (
  'conffiles','config','list','md5sums','postinst',
  'postrm','preinst','prerm','shlibs','templates')

def parse_dist(f,d):
  a=f.readline()
  p={}
  while a:
    if a[:4] in ('Pack','Vers','Arch','Stat','Inst','File','Size','MD5s'):
      a=de_n(a)
      i=a.index(':')
      assert(a[i:i+2] == ': ')
      p[a[:i]] = a[i+2:]
    elif a == '\n':
      d[p['Package']] = p
      p={}
    a=f.readline()


def scan_control(p,params,prefix=None,script=None,stdout = None):
  if prefix == None:
    prefix = ''
  else:
    prefix += '/'
  a=p.readline()
  while a:
    a=de_n(a)
    if a[:4] in ('Pack','Vers','Arch','Stat','Inst','File'):
      if script : script.write('#'+prefix+a+'\n')
      if stdout : stdout.write(' ' + a)
      i=a.index(':')
      assert(a[i:i+2] == ': ')
      params[prefix+a[:i]] = a[i+2:]
    a=p.readline()

def make_parents(f):
  assert(f[0] == '/')
  s=f.split('/')
  d=''
  for a in s[:-1] :
    if a:
      d=d+'/'+a
      if not os.path.exists(d):
        os.mkdir(d)
  d=d+'/'+s[-1]
  return d

def de_n(a):
  if a and a[-1] ==  '\n' :
    a = a[:-1]
  return a

def de_bar(a):
  if a and a[:2] == './' :
    a=a[2:]
  if a and a[0] == '/' :
    a=a[1:]
  return a

def list_ar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list

def list_tar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('tar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list


ALLOWED = '<>()[]{}.,;:!_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r

from string import join

def version_mangle(v):
  if  ':' in v :
    return join(v.split(':'),'%3a')
  else:
    return v

def tempo():
  TD = abspath(tempfile.mkdtemp())
  t=os.getenv('TMPDIR')
  if t == None:
    t='/tmp'
  #this is fascist but still I do not trust my code
  # and if this fails, then __wrap_ fails as well
  if TD[ : len(t) ] != t :
    raise DebDeltaError; ('Sorry I do not like the temp dir "%s"' % TD)
  #
  for i in 'OLD','NEW','PATCH' :
    os.mkdir(TD+'/'+i)
  if  VERBOSE > 2 or KEEP :  print 'Temporary in '+TD
  return TD

##########


class DebDeltaError:
  def __init__(self,s,retriable=False):
    self.__str = s
    self.retriable = retriable
  def __str__(self):
    return self.__str

def die(s=None):
  #if s : sys.stderr.write(s+'\n')
  raise DebDeltaError,s

  
def system(a,TD):
  if type(a) != type('') :
    a=string.join(a,' ')
  t=os.getenv('TMPDIR')
  if t == None:
    t='/tmp'
  if VERBOSE and TD[: (len(t)+4) ] != t+'/tmp' :
    print 'Warning "system()" in ',TD,' for ',a
  ret = os.system("cd '" +TD +"' ; "+a)  
  if ret == 2:
    return KeyboardInterrupt
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    die('Error , non zero return status '+str(ret)+' for command "'+a+'"')

def check_deb(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    die('Error: '+f+ ' does not seem to be a Debian package ')
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    die('Error: '+f+ ' does not seem to be a Debian delta ')
  p.close()

#################################################################### apply patch

def do_patch(delta,olddeb,newdeb,TD):
  if TD[-1] != '/':
    TD = TD + '/'
  
  delta=abspath(delta)
  if newdeb:
    newdeb=abspath(newdeb)
  if olddeb != '/':
    olddeb=abspath(olddeb)
    
  start_sec = time.time()
  
  check_diff(delta)

  if INFO:
    system('ar x  '+delta+' patch.sh patch.sh.gz patch.sh.bz2 2> /dev/null', \
           TD+'/PATCH')
  else:    
    if olddeb != '/':
      check_deb(olddeb)
    if  newdeb and os.path.exists(newdeb) :
      os.rename(newdeb,newdeb+'~')
    system('ar xo '+delta,  TD+'/PATCH')
    
  os.symlink(minigzip,TD+'minigzip')

  if os.path.exists(TD+'PATCH/patch.sh.gz'):
    system('gunzip PATCH/patch.sh.gz',TD)
  elif os.path.exists(TD+'PATCH/patch.sh.bz2'):
    system('bunzip2 PATCH/patch.sh.bz2',TD)  

  #lets scan parameters, to see what it does and what it requires
  params={}
  if not os.path.isfile(TD+'PATCH/patch.sh'):
    die('Error. File '+delta+' is not a debdelta file.')
  p=open(TD+'PATCH/patch.sh')
  s=p.readline()
  #skip #!/bin/sh
  if s[:2] == '#!' :
    s=p.readline()
  while s :
    if s[0] == '#' :
      s=de_n(s)[1:]
      if VERBOSE > 1 or (VERBOSE and action != 'deltas' and \
                         action != 'delta-upgrade' ) or INFO :
        print ' info: ',s
      if ':' in s:
        i=s.index(':')  
        params[s[:i]] = s[i+2:]
      else:
        params[s] = True
    s=p.readline()
  p.close()

  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)
    if olddeb == '/':
      instsize=int(params['NEW/Installed-Size'])
    else:
      instsize=int(params['NEW/Installed-Size'])+int(params['OLD/Installed-Size'])
    if free and free < ( instsize * 1024 + 2**23) :
      raise DebDeltaError(' Not enough disk space (%dkB) for applying delta (needs %dkB).' % \
          ( int(free/1024) , instsize ), True )

  ## really we will apply the patch
  if not INFO:
    #unpack the old control structure, if available
    os.mkdir(TD+'/OLD/CONTROL')
    if olddeb != '/' :
      os.symlink(olddeb,TD+'/OLD.file')
      #unpack control.tar.gz
      system('ar p '+TD+'OLD.file control.tar.gz | tar -x -z -p -f - -C '+TD+'OLD/CONTROL',\
             TD)
    #then we check for the conformance
    if  DEBUG:
      dpkg_params={}
      b=params['OLD/Package']
      if olddeb == '/' :
        p=os.popen('env -i dpkg -s '+b)
      else:        
        p=open(TD+'OLD/CONTROL/control')
      scan_control(p,dpkg_params,'OLD')
      p.close()
      if  olddeb == '/' :
        if 'OLD/Status' not in dpkg_params:
          die('Error: package %s is not known to dpkg.' % b)
        if  dpkg_params['OLD/Status'] != 'install ok installed' :
          die('Error: package %s is not installed, status is %s.'
            % ( b , dpkg_params['OLD/Status'] ) )
      for a in  params:
        if a[:3] == 'OLD' and a != 'OLD/Installed-Size':
          if a not in dpkg_params:
            die('Error parsing old control file , parameter %s not found' % a)
          elif  params[a] != dpkg_params[a] :
            die( 'Error : in debdelta , '+a+' = ' +params[a] +\
                 '\nin old/installed deb, '+a+' = ' +dpkg_params[a])

    ###see into parameters: the patch may need extra info
    #as a whole unpack of 'ar' of the old deb
    if 'unpack-old' in params:
      if olddeb == '/':
        die('This patch needs the old version Debian package')
      unpack ('OLD',olddeb,TD)

    if 'needs-old' in params and olddeb == '/':
      die('This patch needs the old version Debian package')

    if 'old-data-tree' in params :
      os.mkdir(TD+'/OLD/DATA')
      if olddeb == '/':
        pa=params['OLD/Package']
        s=[]
        p=os.popen('env -i dpkg -L '+pa)
        a=p.readline()
        while a:
          a=de_n(a)
          #support diversions
          if a[:26] == 'package diverts others to:':
            continue
          if s and a[:11] == 'diverted by' or  a[:20] == 'locally diverted to:':
            orig,divert=s.pop()            
            i = a.index(':')
            divert = a[i+2:]
            s.append( (orig,divert) )
          else:
            s.append( (a,a) )
          a=p.readline()
        p.close()        
        for orig,divert in s:          
          if os.path.isfile(divert) and not os.path.islink(divert) :            
            a=make_parents(TD+'/OLD/DATA'+orig)
            if VERBOSE > 3 : print '   symlinking ',divert,' to ',a
            os.symlink(divert, a)
          else:
            if VERBOSE > 3 : print '    not symlinking ',divert,' to ',orig
      else:
        system('ar p '+TD+'OLD.file data.tar.gz | tar -x -z -p -f - -C '+TD+'OLD/DATA', TD)
        def chmod_add(n,m):
          om=S_IMODE(os.stat(n)[ST_MODE])
          nm=om | m
          if nm != om:
            if VERBOSE > 1 : print ' Performing chmod ',n,oct(om),oct(nm)
            os.chmod(n,nm)
        for (dirpath, dirnames, filenames) in os.walk(TD+'OLD/DATA'):
          chmod_add(dirpath,  S_IRUSR | S_IWUSR| S_IXUSR  )
          for i in filenames:
            i=os.path.join(dirpath,i)
            if os.path.isfile(i):
              chmod_add(i,  S_IRUSR   )
          for i in dirnames:
            i=os.path.join(dirpath,i)
            chmod_add(i,  S_IRUSR | S_IWUSR| S_IXUSR  )

    if 'old-control-tree' in params and olddeb == '/':      
      p=params['OLD/Package']
      for  b in dpkg_keeps_controls :
        a='/var/lib/dpkg/info/' + p +'.'+b
        if os.path.exists(a ):
          os.symlink(a,TD+'OLD/CONTROL/'+b)

    ##then , really execute the patch
    a=''
    if VERBOSE > 3 : a = '-v'
    system('/bin/sh -e '+a+' PATCH/patch.sh', TD)

    if DEBUG and 'NEW/MD5sum' in params:
      if VERBOSE > 1 : print ' verifying MD5 ', params['NEW/MD5sum']
      system('echo "'+params['NEW/MD5sum']+'  NEW.file" | md5sum -c > /dev/null', TD)

    if newdeb:
      shutil.move(TD+'NEW.file',newdeb)

    if VERBOSE :
      if newdeb:
        debsize = os.stat(newdeb)[ST_SIZE]
      else:
        debsize = os.stat(olddeb)[ST_SIZE]
      end_sec = time.time()
      a=(end_sec - start_sec)
      print ' Patching done, time: %dsec, speed: %dkB/sec, result: %s' % \
            (a,(debsize / 1024 /  (a+.001)), (newdeb))

##################################################### compute delta

def do_delta(olddeb,newdeb,delta,TD):
  if TD[-1] != '/':
    TD = TD + '/'
  
  start_sec = time.time()

  olddeb=abspath(olddeb)
  check_deb(olddeb)
  os.symlink(olddeb,TD+'/OLD.file')

  newdeb=abspath(newdeb)
  check_deb(newdeb)
  os.symlink(newdeb,TD+'/NEW.file')
  newdebsize = os.stat(newdeb)[ST_SIZE]
  
  free=freespace(TD)
  if free and free < newdebsize * 2:
    raise DebDeltaError('Error: not enough disk space in '+TD, True)

  delta=abspath(delta)
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  #generater for numbered files
  def a_numb_file_gen():    
    deltacount = 0
    while 1:
      yield str(deltacount)
      deltacount+=1      
  a_numb_file=a_numb_file_gen()
  
  #start writing script 
  script=open(TD+'PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')
  
  if DEBUG:
    # compute a MD5 of NEW deb
    p=os.popen('md5sum '+TD+'NEW.file')
    a=p.readline()
    p.read()
    p.close
    new_md5sum=a[:32]
    script.write('#NEW/MD5sum: '+ new_md5sum[:32]+'\n')
  else:
    new_md5sum=None
  
  ##### unpack control.tar.gz, scan control, write  parameters
  params={}
  for o in 'OLD', 'NEW' :
      os.mkdir(TD+o+'/CONTROL')
      #unpack control.tar.gz
      system('ar p '+TD+o+'.file control.tar.gz | tar -x -z -f - -C '+TD+o+'/CONTROL',TD)
      ## scan control
      if  VERBOSE  :
        s=sys.stdout
        s.write(o+': ')
      else:
        s=None
      p=open(TD+'/'+o+'/CONTROL/control') 
      scan_control(p,params,o,script,s)
      p.close()
      if s: print
      del s,p


  #### check for disk space
  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)  
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      raise DebDeltaError(' Not enough disk space (%dkB) for creating delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) , True )

    
  ############# check for conffiles 
  a=TD+'/OLD/CONTROL/conffiles'
  if os.path.exists(a):
    p=open(a)
    old_conffiles=[ de_bar(a) for a in p.read().split('\n') ]
    p.close()
  else:
    old_conffiles=()

  def shell_not_allowed(name):
    "Strings that I do not trust to inject into the shell script; maybe I am a tad too paranoid..."
    #FIXME should use it , by properly quoting for the shell script
    return '"' in name or "'" in name or '\\' in name or '`' in name 

  # uses MD5 to detect identical files (even when renamed)
  def scan_md5(n):
    md5={}
    f=open(n)
    a=1
    while a:
      a=de_n(f.readline())
      m , n = a[:32] ,  de_bar( a[34:] )
      md5[n]=m
    f.close()
    return md5


  new_md5=None
  if os.path.exists(TD+'/NEW/CONTROL/md5sums'):
    new_md5=scan_md5(TD+'/NEW/CONTROL/md5sums')
    
  old_md5=None
  if os.path.exists(TD+'/OLD/CONTROL/md5sums') :
    old_md5=scan_md5(TD+'/OLD/CONTROL/md5sums')

  ############### some routines  to prepare delta of two files

  def patch_append(f):
    if VERBOSE > 1 :
      a=os.stat(TD+'PATCH/'+f)[ST_SIZE]
      print '  appending ',f,' of size ', a,' to debdelta, %3.2f'  % ( a * 100. /  newdebsize ) , '% of new .deb'
    system(['ar','qSc', delta,f],  TD+'/PATCH')
    unlink(TD+'PATCH/'+f)

  def verbatim(f):
    pp=a_numb_file.next()
    p = 'PATCH/'+pp
    if VERBOSE > 1 : print '  including "',name,'" verbatim in patch'
    os.rename(TD+f,TD+p)
    patch_append(pp)
    return p
      
  def unzip(f, in_script_as_well = None):
    c=''
    if f[-3:] == '.gz' :
      system('gunzip '+f,TD)
      if in_script_as_well or ( in_script_as_well == None and f[:3] != 'NEW' ):
        script.write('gunzip '+f+'\n')
      f=f[:-3]
      c='.gz'
    elif  f[-3:] == '.bz2' :
      print 'WARNING ! ',f,' is in BZIP2 format ! please fixme !'
    return (f,c)

  def script_zip(n,cn):
    if cn == '.gz' :
      script.write('./minigzip -9 '+n+'\n')
    elif  cn == '.bz2' :
      print 'WARNING ! ',n,' is in BZIP2 format ! please fixme !'
      
  def delta_files(o,n,unzip_p=True):
    " compute delta of two files , and prepare the script consequently"
    nsize = os.stat(TD+n)[ST_SIZE]
    osize = os.stat(TD+o)[ST_SIZE]
    if VERBOSE > 1 : print '  compute delta for %s (%dkB) and %s (%dkB)' % \
       (o,osize/1024,n,nsize/1024)
    if unzip_p:
      (o,co) = unzip(o)
      (n,cn) = unzip(n)
    else:
      co=''
      cn=''
    pp=a_numb_file.next()
    p = 'PATCH/'+pp
    ## according to the man page,
    ## bsdiff uses memory equal to 17 times the size of oldfile
    ## but , in my experiments, this number is more like 12
    #free=freespace(TD)
    #if free == None :
    #  free = MAXMEMORY * 16
    #    #this interferes with chhnked  and (osize < (free / 8)) :
    if not ALLOW_XDELTA or ( osize < (MAXMEMORY / 12)):    
      if osize > ( 1.1 * (MAXMEMORY / 12))  and VERBOSE  :
        print '  Warning, memory usage by bsdiff on the order of %dMb' % (12 * osize / 2**20)
      system('bsdiff  '+o+' '+n+' '+p,TD)
      script.write('bspatch '+o+' '+n+' '+p+'\n')
      script.write('rm '+p+' '+o+'\n')
    else:
      a=''
      if VERBOSE > 2 : print '    fallback on xdelta instead of bsdiff' ; a = '-v'
      system('xdelta delta -n -0 -m'+str(int(MAXMEMORY/1024))+'k '+o+' '+n+' '+p,TD)
      system('bzip2 -9 '+a+' '+p,TD)
      script.write('bunzip2 '+p+'.bz2\n')
      script.write('xdelta patch '+p+' '+o+' '+n+'\n')
      script.write('rm '+p+' '+o+'\n')
      pp += '.bz2'
      p  += '.bz2'
    script_zip(n,cn)
    ## how did we fare ?
    deltasize = os.stat(TD+p)[ST_SIZE]
    if VERBOSE > 1 :
      print '   delta is %3.2f'  % ( deltasize * 100. /  nsize ) , '% of ',n,\
            ', %3.2f'  % ( deltasize * 100. /  newdebsize ) , '% of new .deb'
    #save it
    patch_append(pp)
    #clean up
    unlink(TD+o)
    unlink(TD+n)

  ########### helper sh functions for script, for delta_tar()

  import difflib

  def file_similarity_premangle(oo):
    o=oo.split('/')
    (ob,oe)=os.path.splitext(o[-1])
    return o[:-1]+ ob.split('_')+[oe]
  def files_similarity_score__(oo,nn):
    if oo == nn :
      return 0
    d=difflib.context_diff(oo,nn,'','','','',0,'')
    d=[a for a in tuple(d) if a and a[:3] != '---' and a[:3] != '***' ]
    if oo[-1] != nn[-1] : #penalty for wrong extension
      return 0.2+float(len(d)) * 2.0 / float(len(oo)+len(nn))
    else:
      return float(len(d)) * 2.0 / float(len(oo)+len(nn))
  def files_similarity_score(oo,nn):
    if oo == nn :
      return 0
    if type(oo) == type(''):
      oo=file_similarity_premangle(oo)
    if type(nn) == type(''):
      nn=file_similarity_premangle(nn)
    return files_similarity_score__(oo,nn)

  def fake_tar_header_2nd():
    " returns the second part of a tar header , for regular files and dirs"
    # The following code was contributed by Detlef Lannert.
    # into /usr/lib/python2.3/tarfile.py
    MAGIC      = "ustar"            # magic tar string
    VERSION    = "00"               # version number
    NUL        = "\0"               # the null character
    parts = []
    for value, fieldsize in (
      ("", 100),
      # unfortunately this is not what DPKG does
      #(MAGIC, 6),
      #(VERSION, 2),
      #  this is  what DPKG does
      ('ustar  \x00',8),
      ("root", 32),
      ("root", 32),
      ("%07o" % 0, 8),
      ("%07o" % 0, 8),
      ("", 155)
      ):
      l = len(value)
      parts.append(value + (fieldsize - l) * NUL)      
    buf = "".join(parts)
    return buf
  
  fake_tar_2nd=fake_tar_header_2nd()
  fake_tar_2nd_echo=prepare_for_echo(fake_tar_2nd)
  script.write("FTH='"+fake_tar_2nd_echo+"'\n")
  
  script.write('CR () { cat "$1"  >> OLD/mega_cat ; rm "$1" ;}\n')

  ##########################################################################
  def delta_tar(old_filename,new_filename,CWD,skip=(),old_md5={},new_md5={}):
    " compute delta of two tar files, and prepare the script consequently"
    assert( type(old_filename) == StringType or type(old_filename) == FunctionType )
    if os.path.exists(TD+'OLD/mega_cat'):
      # if -k is given, still we need to delete it...
      os.unlink(TD+'OLD/mega_cat')
    mega_cat=open(TD+'OLD/mega_cat','w')
    #helper function
    def _append_(w,rm=False):
      f=open(TD+w)
      a=f.read(1024)
      while a:
        mega_cat.write(a)
        a=f.read(1024)
      f.close()
      if rm:
        script.write("CR '"+w+"'\n")
        unlink(TD+w)
      else:
        script.write("cat '"+w+"'  >> OLD/mega_cat\n")

    #### scan once for regular files
    if type(old_filename) == StringType :
      (old_filename,old_filename_ext) = unzip(old_filename,False)
      oldtar = tarfile.open(TD+old_filename, "r")
    else:
      old_filename_ext=None
      oldfileobj = old_filename()
      oldtar = tarfile.open(mode="r|", fileobj=oldfileobj)
    oldnames = []
    oldtarinfos = {}
    for oldtarinfo in oldtar:
      oldname = oldtarinfo.name
      if  (oldname in skip) or shell_not_allowed(oldname) or \
             not oldtarinfo.isreg() or oldtarinfo.size == 0:
        continue
      if VERBOSE > 2 and oldname != de_bar(oldname):
        print ' Weird filename in old tar: ' , oldname 
      oldname = de_bar(oldname)
      if oldname in skip:
        continue
      oldnames.append(oldname)
      oldtarinfos[oldname] = oldtarinfo
      oldtar.extract(oldtarinfo,TD+"OLD/"+CWD )
    oldtar.close()
    if type(old_filename) == StringType :
      unlink(TD+old_filename)
    else:
      while oldfileobj.read(512):
        pass
    (new_filename,new_filename_ext) = unzip(new_filename)
    assert(0 == (os.path.getsize(TD+new_filename)% 512))
    newtar = tarfile.open(TD+new_filename, "r")
    newnames = []
    newtarinfos = {}
    for newtarinfo in newtar:
      newname =  newtarinfo.name
      #just curious to know
      a=("%o" % newtarinfo.mode)
      t=newtarinfo.type
      if VERBOSE and (( t == '2' and a  != '777' ) or \
                      ((t == '5' or t == '0') and (a not in [ '755' , '644' ]))):
        print ' Weird permission: ',newname,a,repr(newtarinfo.type)
      ###
      if   not newtarinfo.isreg():
        continue
      if VERBOSE > 2 and newname != de_bar(newname):
        print ' Weird filename in new tar: ' , newname 
      newname = de_bar(newname)
      newnames.append(newname)
      newtarinfos[newname] = newtarinfo
      
    old_used={}
    correspondence={}

    ##############################
    if VERBOSE > 2 : print '  finding correspondences  ',n
    reverse_old_md5={}
    if old_md5:
      for o in old_md5:
        reverse_old_md5[old_md5[o]] = o

    oldnames_premangle={}
    for o in oldnames:
      oldnames_premangle[o]=file_similarity_premangle(o)

    for newname in newnames:
      newtarinfo=newtarinfos[newname]
      oldname=None
      #ignore empty files
      if newtarinfo.size == 0:
        continue
      #try correspondence by MD5
      if new_md5 and newname in new_md5:
        md5=new_md5[newname]        
        if md5 in reverse_old_md5:
          oldname=reverse_old_md5[md5]
          if VERBOSE > 2 :
            if oldname  == newname :
              print '   use identical old file: ',newname
            else:
              print '   use identical old file: ',oldname, newname
      #try correspondence by file name
      if oldname == None and newname in oldnames:
        oldname=newname
        if VERBOSE > 2 : print '   use same name old file: ',newname
      #try correspondence by file name and len similarity
      if oldname == None:
        basescore=0.6
        nl=newtarinfo.size
        np=file_similarity_premangle(newname)
        for o in oldnames:
          l=oldtarinfos[o].size
          s=files_similarity_score__(oldnames_premangle[o],np) + abs(float(l - nl))/float(l+nl)
          #print ' diff ',s,o
          if s < basescore:
              oldname=o
              basescore=s
        if oldname and VERBOSE > 2 : print '   best similar  ',int(100*basescore),newname,oldname
      if not oldname:
        if VERBOSE > 2 : print '   no correspondence for: ',newname
        continue
      #we have correspondence, lets store
      if oldname not in old_used:
        old_used[oldname]=[]
      old_used[oldname].append(newname)
      correspondence[newname]=oldname

    ######### now do real scanning
    if VERBOSE > 2 : print '  scanning ',n

    #helper function
    def mega_cat_chunk(oldoffset,newoffset):
      p = 'PATCH/tmp_new_tar'
      f=open(TD+new_filename)
      f.seek(oldoffset)
      of=open(TD+p,'w')
      l=oldoffset
      while l<newoffset:
        s=f.read(512)
        l+=len(s)
        assert(len(s))
        of.write(s)
      f.close()
      of.close()
      delta_files('OLD/mega_cat',p)
      script.write('cat '+p+' >> '+new_filename+'; rm '+p+'\n')
      os.unlink(p)

    #there may be files that have been renamed and edited...
    def some_old_file_gen():
      for oldname in oldnames :
        if (oldname in skip) or (oldname in old_used ) :
          continue
        if VERBOSE > 2 : print '   provide also old file ', oldname
        yield oldname
      while 1:
        yield None

    some_old_file=some_old_file_gen()
    one_old_file=some_old_file.next()

    progressive_new_offset=0

    for newtarinfo in newtar:
      #progressive mega_cat
      a=mega_cat.tell()
      if (a >= MAXMEMORY / 12 ) or \
         (a >= MAXMEMORY / 13 and one_old_file ) or \
         (a>0 and (a+newtarinfo.size) >= MAXMEMORY / 12):
        #provide some old unused files, if any
        while one_old_file:
          _append_("OLD/"+CWD+"/"+one_old_file)
          if mega_cat.tell() >= MAXMEMORY / 12:
            break
          one_old_file=some_old_file.next()
        mega_cat.close()
        mega_cat_chunk(progressive_new_offset, newtarinfo.offset )
        progressive_new_offset=newtarinfo.offset
        mega_cat=open(TD+'OLD/mega_cat','w')
      #
      name = de_bar( newtarinfo.name )
      #recreate also parts of the tar headers
      mega_cat.write(newtarinfo.name+fake_tar_2nd)
      s=prepare_for_echo(newtarinfo.name)
      script.write("echo -n -e '"+ s +"'\"$FTH\" >> OLD/mega_cat\n")

      if newtarinfo.isdir():
        if VERBOSE > 2 : print '   directory   in new : ', name
        continue

      if not newtarinfo.isreg():
        if VERBOSE > 2 : print '   not regular in new : ', name
        continue

      if newtarinfo.size == 0:
        if VERBOSE > 2 : print '   empty  new file    : ', name
        continue

      if name not in correspondence:
        if VERBOSE > 2: print '   no corresponding fil: ', name
        continue 
      oldname = correspondence[name]
      
      mul=len( old_used[oldname]) > 1 #multiple usage
      if VERBOSE > 2 :  print '   adding reg file: ', oldname, mul and '(multiple)' or ''
      _append_( "OLD/"+CWD+"/"+oldname , not mul )
      old_used[oldname].pop()


    mega_cat.close()
    if os.path.exists(TD+'/OLD/'+CWD):
      rmtree(TD+'/OLD/'+CWD)
    if os.path.getsize(TD+'OLD/mega_cat') > 0 :
      if progressive_new_offset > 0 :
        mega_cat_chunk(progressive_new_offset, os.path.getsize(TD+new_filename))
      else:
        delta_files('OLD/mega_cat',new_filename)
    else:
      p=verbatim(new_filename)
      script.write('mv '+p+' '+new_filename+ '\n')
    script_zip(new_filename,new_filename_ext)
  ############ start computing deltas

  def append_NEW_file(s):
    'appends some data to NEW.file'
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")
    
  if NEEDSOLD :
    #this delta needs the old deb 
    script.write('#needs-old\n')

  #this following is actually
  #def delta_debs_using_old(old,new):

  ### start scanning the new deb  
  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append_NEW_file(s)

  #process all contents of old vs new .deb
  ar_list_old= list_ar(TD+'OLD.file')
  ar_list_new= list_ar(TD+'NEW.file')

  for name in ar_list_new :
    n = 'NEW/'+name
    system('ar p '+TD+'NEW.file '+name+' >> '+TD+n,TD)

    newsize = os.stat(TD+n)[ST_SIZE]
    if VERBOSE > 1: print '  studying ' , name , ' of len %dkB' % (newsize/1024)
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 3: print '  ar line: ',repr(s)
    assert( s[:len(name)] == name and s[-2] == '`' and s[-1] == '\n' )
    append_NEW_file(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(newsize  ,1)
    if newsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if newsize < 128:      #file is too short to compute a delta,
      p=open(TD+n)
      append_NEW_file( p.read(newsize))
      p.close()
      unlink(TD+n)
    elif  name[:11] == 'control.tar' :
      #(mm this is almost useless, just saves a few bytes)
      script.write('#old-control-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o, TD)
      ##avoid using strange files that dpkg may not install in /var...info/
      skip=[]
      for a in os.listdir(TD+'OLD/CONTROL') :
        if a not in dpkg_keeps_controls:
          skip.append(a)
      #delta it
      delta_tar(o,n,'CONTROL',skip)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif not NEEDSOLD and name[:8] == 'data.tar'  :
      script.write('#old-data-tree\n')
      o = 'OLD/'+name
      #system('ar p OLD.file '+name+' >> '+o, TD)
      assert(name[-3:] == '.gz')#should add support for bz2 data.tar
      def x():
        return os.popen('cd '+TD+'; ar p OLD.file '+name+' | gzip -cd')
      delta_tar(x,n,'DATA',old_conffiles,old_md5,new_md5)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif  not NEEDSOLD  or name not in ar_list_old :   #or it is not in old deb
      p=verbatim(n)
      script.write('cat '+p+' >> NEW.file ; rm '+p+'\n')
    elif  NEEDSOLD :
      #file is long, and has old version ; lets compute a delta
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o, TD)
      script.write('ar p OLD.file '+name+' >> '+o+'\n')
      delta_files(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    else:
      die('internal error')
    #pad new deb
    if extrachar :
      append_NEW_file(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if s:
    if VERBOSE > 2: print '   ar leftover character: ',repr(s)
    append_NEW_file(s)

  if DEBUG > 1 and new_md5sum :
    script.write('echo "'+new_md5sum+'  NEW.file" | md5sum -c > /dev/null')

  #script is done
  script.close()
  patchsize = os.stat(TD+'PATCH/patch.sh')[ST_SIZE]
  if  (patchsize > newdebsize / 10 and patchsize > 512 ) or patchsize > 4*1024:
    v=''
    if VERBOSE > 1 : print '  patch.sh is quite large: using bzip2 ' ; v='-v'
    system('bzip2 -9  '+v+'  PATCH/patch.sh', TD)
    patch_append('patch.sh.bz2')
  else:
    v=''
    if VERBOSE > 1 : print '  patch.sh is small: using gzip ' ; v='-v'
    system('gzip -9 -n '+v+' PATCH/patch.sh', TD)  
    patch_append('patch.sh.gz')

  deltasize = os.stat(delta)[ST_SIZE]
  
  elaps =  time.time() - start_sec
  percent =  deltasize * 100. /  newdebsize 
  if VERBOSE:
    print ' deb delta is  %3.1f%% of deb; that is, %dkB are saved, on a total of %dkB.' \
          % ( percent , (( newdebsize -deltasize ) / 1024),( newdebsize/ 1024))
    print ' delta time: %dsec, speed: %dkB per second ' %  \
          (elaps, newdebsize / 1024 / (elaps+0.001))
  return (delta, percent, elaps)


##################################################### compute many deltas

def do_deltas(argv):
  original_cwd = os.getcwd()
  import warnings
  warnings.simplefilter("ignore",FutureWarning)
  try:
    from apt import VersionCompare
  except ImportError:
    import apt_pkg
    apt_pkg.InitSystem()
    from apt_pkg import VersionCompare

  if AVOID and type(AVOID) == type(''):
    import shelve
    if VERBOSE: print ' Using avoid dict ',AVOID
    avoid_pack = shelve.open(AVOID,'r')
  else:
    avoid_pack = {}
  
  debs=[]
  for i in argv:
    debs.append(i)

  info_by_pack_arch={}
  info_by_file={}

  def scan_deb(f):
      info_by_file[f]={}
      p=os.popen('ar p '+f+' control.tar.gz | tar -x -z -f - -O ./control')
      scan_control(p,info_by_file[f])
      p.close()
      info_by_file[f]['File'] = f
      pa=info_by_file[f]['Package']
      ar=info_by_file[f]['Architecture']
      if  (pa,ar) not in  info_by_pack_arch :
         info_by_pack_arch[ (pa,ar) ]=[]
      info_by_pack_arch[ (pa,ar) ].append( info_by_file[f] )

  for f in debs:
    if os.path.isfile(f):
      scan_deb(f)
    elif  os.path.isdir(f) :
      for a in  filter( lambda a : a[-4:] == '.deb' ,os.listdir(f) ) :
        scan_deb(f+'/'+a)
    else:
      print 'Warning: '+f+' is not a regular file or a directory.'
      
  def order_by_version(a,b):
    return VersionCompare( a['Version'] , b['Version']  )
  
  for pa,ar in info_by_pack_arch :
    how_many= len( info_by_pack_arch[ (pa,ar) ] )    
    if VERBOSE>2:
      print '   I see: ',pa,[ o['Version'] for o in info_by_pack_arch[(pa,ar)]]
      
    if how_many > 1 :
      info_by_pack_arch[ (pa,ar) ].sort(order_by_version)
      l = how_many - 1
      while (l>0) and (l >= how_many - N_DELTAS):
        #os.chdir(original_cwd)
        l -= 1
        old=info_by_pack_arch[ (pa,ar) ][l]
        new=info_by_pack_arch[ (pa,ar) ][how_many - 1]

        if pa in avoid_pack and ( avoid_pack[pa]['Version'] == old['Version']):
          if VERBOSE > 1 :     print '(Due to old version) avoid: ', new['File']
          break        

        if pa in avoid_pack and ( avoid_pack[pa]['Version'] == new['Version']) :
          if VERBOSE > 1 :     print '(Due to new version) avoid: ', new['File']
          break        
        
        newdebsize=os.stat(new['File'])[ST_SIZE]
        #very small packages cannot be effectively delta-ed
        if newdebsize <= 4 * 1024 :
          #this actually affects 1 every ~60 packages in the archives
          if VERBOSE > 1:     print '  Skip , too small: ', new['File']
          break
        
        assert( old['Package'] == pa and pa == new['Package'] )
        deltabasename = pa +'_'+  version_mangle(old['Version']) +\
                        '_'+ version_mangle(new['Version']) +'_'+ar+'.debdelta'
        if DIR:
          if DIR[-2:] == '//' :
            a=DIR+os.path.dirname(new['File'])+'/'+deltabasename
            delta=make_parents(a)
          else:
            delta = DIR+'/'+deltabasename
        else:
          delta = os.path.dirname(new['File']) + '/'+deltabasename
          
        if os.path.exists(delta):
          if VERBOSE > 1:     print '  Skip , already exists: ',delta
          break
        if os.path.exists(delta+'-too-big'):
          if VERBOSE > 1:     print '  Skip , tried and too big: ',delta
          break

        if os.path.exists(delta+'-fails'):
          if VERBOSE > 1:     print '  Skip , tried and fails: ',delta
          break

        free=freespace(os.path.dirname(delta))
        if free and (free < (newdebsize /2 + 1024)) :
          if VERBOSE : print 'Not enough disk space for storing ',delta
          break
        
        if VERBOSE: print 'Creating :',delta
        ret= None
        T=tempo()          
        try:
          ret=do_delta(old['File'],new['File'], delta,T)
        except DebDeltaError,s:
          #os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          if not VERBOSE: print 'Creating: ',delta
          print ' Creation of delta failed, reason: ',str(s)
          if not s.retriable :
            p=open(delta+'-fails','w')
            p.close()
        except:
          #os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          rmtree(T)
          raise
        #os.chdir(original_cwd)
        rmtree(T)

        if ret and MAX_DELTA_PERCENT:
          deltasize=os.stat(delta)[ST_SIZE]
          if ( ret[1] > (MAX_DELTA_PERCENT+10)  ) or \
            ( ret[1] > (MAX_DELTA_PERCENT+5) and  deltasize >= 150*1024)  or \
            ( ret[1] > (MAX_DELTA_PERCENT-5) and  deltasize >= 1500*1024) or \
            ( ret[1] > (MAX_DELTA_PERCENT-10) and  deltasize >= 15000*1024):
            os.unlink(delta)
            if VERBOSE : print ' Warning, too big!'
            p=open(delta+'-too-big','w')
            p.close()
            ret = None

        if DEBUG > 1 and ret :
          T=tempo()
          try:
            do_patch(delta,old['File'],None ,T)
          except DebDeltaError,s:
            print ' Error: testing of delta failed: ',str(s)
            if not  s.retriable :
              p=open(delta+'-fails','w')
              p.close()              
              if os.path.exists(delta):
                os.unlink(delta)
          except:
            print " Unexpected error while testing delta:", sys.exc_info()[0]
            #os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
            rmtree(T)
            raise
          #os.chdir(original_cwd)
          if os.path.exists(T):
            rmtree(T)

################################################# main program, do stuff

if action == 'patch':
  if INFO  :
    if  len(argv) > 1 and VERBOSE :
      print '(printing info - extra arguments are ignored)'
    elif  len(argv) == 0  :
      print ' need a  filename ;  try --help'
      sys.exit(1)
  elif len(argv) != 3 :  
    print ' need 3 filenames ;  try --help'
    sys.exit(1)
  
  newdeb=abspath(argv[2])
  T=tempo()
  try:
    do_patch(abspath(argv[0]), abspath(argv[1]), newdeb ,T)
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    rmtree(T)
    sys.exit(2)
  except KeyboardInterrupt:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
  except:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    raise
  rmtree(T)
  
elif action == 'delta' :
  if len(argv) != 3 :  
    print ' need 3 filenames ;  try --help'
    sys.exit(1)
    
  T=tempo()
  delta=abspath(argv[2])
  try:
    do_delta(abspath(argv[0]), abspath(argv[1]), delta ,T)  
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    rmtree(T)
    if os.path.exists(delta):
      os.unlink(delta)
    sys.exit(2)
  except KeyboardInterrupt:
    if os.path.exists(delta):
      os.unlink(delta)
  except:
    if os.path.exists(delta):
      os.unlink(delta)
    raise
  rmtree(T)
  
elif action == 'deltas' :
  try:
    do_deltas(argv)
  except DebDeltaError,s:
    print 'Failed: ',str(s)
    sys.exit(2)

  
##################################################### delta-upgrade
    
def delta_upgrade():
  original_cwd = os.getcwd()

  import  thread , pickle, urllib

  import warnings
  warnings.simplefilter("ignore",FutureWarning)

  import  apt, apt_pkg
  apt_pkg.init()

  from apt import SizeToStr

  cache=apt.Cache()
  cache.upgrade()

  if DIR == None:
    DEB_DIR='/tmp/archives'
  else:
    DEB_DIR=DIR
  if not os.path.exists(DEB_DIR):    
    os.mkdir(DEB_DIR)
  
  print 'Recreated debs are saved in ',DEB_DIR
  start_sec = time.time()
  len_deltas=0
  len_newdebs=0
      
  (qout,qin)=os.pipe()
  ######################## thread_do_patch
  def thread_do_patch(qout,threads):
      if VERBOSE > 1 : print ' Patching thread started. '
      while 1:
        s=os.read(qout,1)
        c=''
        while s != '\t' :
          c+=s
          s=os.read(qout,1)
        if c == '\t' or c == '': break
        (name, delta , newdeb) = pickle.loads(c)      
        if VERBOSE>=2 : print ' Now patching for: ',name
        if True: 
          T=tempo()
          try:
            ret=do_patch(delta,'/',newdeb ,T)
            if VERBOSE == 0 : print 'Created ',newdeb
          except DebDeltaError,s:
            print ' Error: applying of delta for ',name,'failed: ',str(s)
            if os.path.exists(newdeb):
              os.unlink(newdeb)
          except:
            print " Error while applying delta for ",name,":",sys.exc_info()
            if os.path.exists(newdeb):
              os.unlink(newdeb)
          else:
            if os.path.exists(delta):
              os.unlink(delta)
          #os.chdir(original_cwd)
          if os.path.exists(T):
            rmtree(T)
      threads.pop()
      if VERBOSE > 1 : print ' Patching thread ended , bye bye. '
      return len_newdebs

  threads=[]
  threads.append(thread.start_new_thread(thread_do_patch  , (qout,threads) ) )

  len_downloaded=0
  conn_time=0

  import httplib
  from urlparse import urlparse

  a=urlparse(DELTA_URL)
  assert(a[0] == 'http')
  deltas_conn=httplib.HTTPConnection(a[1])
  delta_http_base=a[2]


  #these are the packages that do not have a delta
  no_delta = []

  ###################################### download_uri
  def test_uri(conn,uri):
      a='Url'
      if uri[-9:] == '.debdelta':
        a='Debdelta'
      s=uri[-60:]
      conn.request("HEAD", urllib.quote(uri))
      r = conn.getresponse()
      r.read()
      r.close()
      if r.status == 200:
        if VERBOSE > 2: print a,' is present: ',s
        return r
      if not VERBOSE: return None        
      if uri[-9:] == '.debdelta':
        conn.request("HEAD", urllib.quote(uri+'-too-big'))
        r2 = conn.getresponse()
        r2.read()
        r2.close()
        if r2.status == 200:
          print a,' is too big: ',s
          return None
      if r.status == 404:
        print a,'is not present: ',s
      else:
        print a,'is not available (',repr(r.status), r.reason,'): ', s
      return None
  ###################################### test_uri
  def download_uri(conn,uri,outname,conn_time,len_downloaded):
      conn.request("GET", urllib.quote(uri))
      r = conn.getresponse()
      if r.status != 200:
        if VERBOSE: print 'Not present: ...',uri
        r.read()
        r.close()
        return None
      length=r.length
      assert( r.length == int(r.getheader('content-length')) )
      free=freespace(os.path.dirname(outname))
      if free and (free + 2**14 ) < length  :
        print 'Not enough disk space do download: ',os.path.basename(uri)
        return None
      out=open(outname+'.temp','w')
      a=time.time()
      conn_time-=a      
      j=0
      s=r.read(min(1024,r.length))
      while s and j < length:
        j+=len(s)
        out.write(s)
        if a + 0.5 < time.time() :
          a=time.time()
          sys.stderr.write("%d%% (%4s/s) for ...%s \r" % \
                           (100*j / length,
                            SizeToStr((j+len_downloaded)/(a+conn_time)),\
                            uri[-50:]))
        s=r.read(min(1024,r.length))
      out.close()
      r.close()
      conn_time+=time.time()
      sys.stderr.write("Downloaded: ...%s \n" % uri[-60:])
      os.rename(outname+'.temp',outname)
      return  conn_time , (j+len_downloaded)

  
  for p in cache :
    if p.isInstalled and  p.markedUpgrade \
           and p.candidateOrigin[0].origin == 'Debian':

      #thanks a lot to Michael Vogt
      p._lookupRecord(True)
      dpkg_params = apt_pkg.ParseSection(p._records.Record)
      cand = p._depcache.GetCandidateVer(p._pkg)
      deb_path=dpkg_params['Filename']      
      for (packagefile,i) in cand.FileList:
        indexfile = cache._list.FindIndex(packagefile)
        if indexfile:
          deb_uri=indexfile.ArchiveURI(deb_path)
          break      
      
      arch=dpkg_params['Architecture']      
      
      newdeb=p.name+'_'+version_mangle(p.candidateVersion)+'_'+arch+'.deb'
      if os.path.exists(DEB_DIR+'/'+newdeb) or \
             os.path.exists('/var/cache/apt/archives/'+newdeb):
        if VERBOSE > 1 : print  'Already downloaded: ',newdeb
        continue

      if VERBOSE > 1:
        print 'Looking for a delta for %s from %s to %s ' % \
              ( p.name, p.installedVersion, p.candidateVersion )
      
      newdeb = DEB_DIR+'/'+newdeb

      #delta name
      delta_name=p.name+'_'+version_mangle(p.installedVersion)+\
                  '_'+ version_mangle(p.candidateVersion)+'_'+\
                  arch+'.debdelta'

      uri=delta_http_base+'/'+os.path.dirname(deb_path)+'/'+delta_name

      #download delta
      if not os.path.exists(DEB_DIR+'/'+delta_name):
        if VERBOSE:
          r=test_uri(deltas_conn,uri)
        else:
          r=True
        if r:
          r=download_uri(deltas_conn,uri, DEB_DIR+'/'+delta_name,conn_time,len_downloaded)
        if r == None:
          no_delta.append(deb_uri   )
        else:
          conn_time = r[0]
          len_downloaded = r[1]

      #queue to apply delta
      if os.path.exists(DEB_DIR+'/'+delta_name):
        #append to queue
        c=pickle.dumps(  (p.name, DEB_DIR+'/'+delta_name  ,newdeb) )
        os.write(qin, c + '\t' )
        # compute virtual speed . FIXME this is incorrect if patching fails!
        len_newdebs += int( dpkg_params['Size'])

  deltas_conn.close()

  #terminate queue
  os.write(qin,'\t\t\t')
  if threads:
    time.sleep(0.2)
  
  #do something useful in the meantime
  deb_conns={}
  if threads and no_delta:
    if VERBOSE > 1 :
      print ' Downloading deltas done, downloading debs while waiting for patching thread.'
    while threads and no_delta:
      a = no_delta.pop()
      a=urlparse(a)
      assert(a[0] == 'http')
      if a[1] not in deb_conns:        
        deb_conns[a[1]] = httplib.HTTPConnection(a[1])      
      download_uri(deb_conns[a[1]], a[2] , \
                   DEB_DIR+'/'+os.path.basename(a[2]),conn_time,len_downloaded )
    for i in deb_conns:
      deb_conns[i].close()
    
  if VERBOSE > 1 : print ' Downloading done, waiting for patching thread. '
  while threads:
    time.sleep(0.2)

  elaps =  time.time() - start_sec
  if 1 or VERBOSE:
    if conn_time:
      print 'Delta-upgrade download time %dsec speed %s/sec' %\
          (int(conn_time), SizeToStr(len_downloaded / conn_time))
      print '              total time: %dsec; virtual speed: %s/sec.' %  \
          (elaps, SizeToStr(len_newdebs / elaps))


####

if action == 'delta-upgrade':
  import warnings
  warnings.simplefilter("ignore",FutureWarning)
  delta_upgrade()

##################################################### apt method

### still work in progress
if  os.path.dirname(sys.argv[0]) == '/usr/lib/apt/methods' :
  import os,sys, select, fcntl, apt, thread, threading, time

  apt_cache=apt.Cache()
  
  log=open('/tmp/log','a')
  log.write('  --- here we go\n')
  
  ( hi, ho , he) = os.popen3('/usr/lib/apt/methods/http.distrib','b',2)

  nthreads=3

  class cheat_apt_gen:
    def __init__(self):
      self.uri=None
      self.filename=None
      self.acquire=False
    def process(self,cmd):
      if self.uri:
        self.filename=cmd[10:-1]
        log.write(' download %s for %s\n' % (repr(self.uri),repr(self.filename)))
        self.uri=None
        self.filename=None
        self.acquire=False
        return cmd
      elif self.acquire:
        self.uri=cmd[5:-1]
        return cmd
      elif cmd[:3] == '600' :
        self.acquire=True
      else:
        return cmd
  
  def copyin():
    bufin=''
    while 1:
      #print ' o'
      s=os.read(ho.fileno(),1)
      bufin += s
      if log and bufin and (s == '' or s == '\n') :
        log.write( ' meth ' +repr(bufin)+'\n' )
        bufin=''
      if s == '':
        thread.interrupt_main(   )
        global nthreads
        if nthreads:
          nthreads-=1
        #log.write( ' in closed \n' )
        #return
      os.write(1,s)


  def copyerr():
    buferr=''
    while 1:
      s=os.read(he.fileno(),1)
      buferr += s
      if log and buferr and (s == '' or s == '\n') :
        log.write( ' err ' +repr(buferr)+'\n' )
        buferr=''
      if s == '':
        thread.interrupt_main(   )
        global nthreads
        if nthreads:
          nthreads-=1
        log.write( ' err closed \n' )
        #return
      os.write(2,s)

  def copyout():
    gen=cheat_apt_gen()
    bufout=''
    while 1:
      s=os.read(0,1)
      bufout += s
      if log and bufout and (s == '' or s == '\n') :
        log.write( ' apt ' +repr(bufout)+'\n' )

        bufout=gen.process(bufout) 
        
        bufout=''
      if s == '':
        thread.interrupt_main()
        global nthreads
        if nthreads:
          nthreads-=1
        #log.write( ' out closed \n' )
        #return
      os.write(hi.fileno(),(s))

        
  tin=thread.start_new_thread(copyin,())
  tout=thread.start_new_thread(copyout,())
  terr=thread.start_new_thread(copyerr,())
  while nthreads>0 :
    log.write( ' nthreads %d \n' % nthreads )
    try:
      while nthreads>0 :
        time.sleep(1)      
    except KeyboardInterrupt:
      pass
  sys.exit(0)

