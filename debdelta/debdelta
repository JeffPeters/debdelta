#!/usr/bin/python

doc={}
doc['delta']="""\
Usage: debdelta [ option...  ] fromfile tofile patchout
  Computes a delta from fromfile to tofile and writes it to patchout

Options:
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb   maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""


doc['deltas']="""\
Usage: debdeltas [ option...  ] debs
  Computes all missing deltas for debs

Options:
--dir DIR   force saving of deltas in this DIR
            (otherwise they go in the dir of the newer deb)
            if DIR ends in // , then the dirname of the arguments will be used as well
--search    search in the directory of the above debs for older versions
--needsold  create a patch that can only be used if the old .deb is available
  -M Mb     maximum memory (to decide if using 'bsdiff' or 'xdelta')
"""

doc['patch']="""\
Usage: debpatch [ option...  ] patchin  fromfile  tofile 
  Applies patchin to fromfile and produces a reconstructed  version of tofile.

(When using 'debpatch' and the old .deb is not available,
  use '/' for the fromfile.)

Usage: debpatch --info  patch
  Write info on patch.

Options:
"""

doc_common="""
  -v      verbose (can be added multiple times)
  -k      keep temporary files
"""

## currently this is always true:
## -d      debug : add md5sums, check that  versions do match

minigzip='/usr/lib/debdelta/minigzip'


####################################################################

import sys , os , tempfile , string ,getopt , tarfile , shutil , time

from stat    import ST_SIZE
from os.path import abspath
from os      import unlink, rmdir
from shutil  import rmtree

################################################# main program, read options



action=(os.path.basename(sys.argv[0]))[3:]
actions =  ('delta','patch','deltas')
if action not in actions:
  print 'wrong filename: should be "deb" + '+repr(actions)
  sys.exit(0)

__doc__ = doc[action] + doc_common

( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                               ('help','info','needsold','dir=') )



MAXMEMORY = 1024 * 1024 * 50

MAX_DELTA_PERCENT = 50

DEBUG   = 1
VERBOSE = 0
KEEP    = False
INFO    = False
NEEDSOLD= False
DIR     = None

for  o , v  in  opts :
  if o == '-v' : VERBOSE += 1
  elif o == '-d' : DEBUG += 1
  elif o == '-k' : KEEP = True
  elif o == '--needsold' and action == 'delta' :  NEEDSOLD = True
  elif o == '-M' and action == 'delta' :    MAXMEMORY = 1024 * 1024 * int(v)
  elif o == '--info' and action == 'patch' : INFO = True
  elif o == '--dir'  and action == 'deltas' :
    DIR = v
    if not os.path.isdir(DIR):
      print 'Error: --dir ',DIR,' does not exist.'
      sys.exit(3)
  elif o ==  '--help' or o ==  '-h':
    print __doc__
    sys.exit(0)
  else:
    print ' option ',o,'is unknown, try --help'
    sys.exit(1)

if INFO  :
  if  len(argv) > 1 and VERBOSE :
    print '(printing info - extra arguments are ignored)'
  elif  len(argv) == 0  :
    print ' need a  filename ;  try --help'
    sys.exit(1)
elif action != 'deltas' and len(argv) != 3 :  
  print ' need 3 filenames ;  try --help'
  sys.exit(1)


if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a
  def rmtree(a):
    if VERBOSE : print ' would rm -r ',a

#################################################### various routines

def freespace(w):
  try:
    a=os.statvfs(w)
    freespace= a[0] * a[4]
  except:
    if VERBOSE : print ' statvfs error ',a
    freespace=None
  return freespace

dpkg_keeps_controls = (
  'conffiles','config','list','md5sums','postinst',
  'postrm','preinst','prerm','shlibs','templates')

def scan_control(p,params,prefix=None,script=None,stdout = None):
  if prefix == None:
    prefix = ''
  else:
    prefix += '/'
  a=p.readline()
  while a:
    a=de_n(a)
    if a[:4] in ('Pack','Vers','Arch','Stat','Inst'):
      if script : script.write('#'+prefix+a+'\n')
      if stdout : stdout.write(' ' + a)
      i=a.index(':')
      assert(a[i:i+2] == ': ')
      params[prefix+a[:i]] = a[i+2:]
    a=p.readline()

def make_parents(f):
  assert(f[0] == '/')
  s=f.split('/')
  d=''
  for a in s[:-1] :
    if a:
      d=d+'/'+a
      if not os.path.exists(d):
        os.mkdir(d)
  d=d+'/'+s[-1]
  return d

#def symlink_w_parents(f,d):
#  d=make_parents(fd)
#  os.symlink(f,d)

def de_n(a):
  if a[-1] ==  '\n' :
    a = a[:-1]
  return a


def list_ar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list

def list_tar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('tar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list


def unpack(d,f,T):
  "unpacks 'ar' file f in directory d"
  assert(os.path.exists(f))
  cwd = os.getcwd()
  os.chdir(T+'/'+d)
  system('ar xo '+f)
  os.chdir(cwd)


ALLOWED = '<>()[]{}.,;:!_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r



def tempo():
  TD = abspath(tempfile.mkdtemp())
  for i in 'OLD','NEW','PATCH' :
    os.mkdir(TD+'/'+i)
  if  VERBOSE > 2 or KEEP :  print 'Temporary in '+TD
  return TD

##########


class DebDeltaError:
  def __init__(self,s):
    self.__str = s
  def __str__(self,s):
    return __str

def die(s=None):
  if s : sys.stderr.write(s+'\n')
  raise DebDeltaError,s

  
def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if ret == 2:
    return KeyboardInterrupt
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    die('Error , non zero return status '+str(ret)+' for command "'+a+'"')

def check_deb(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    die('Error: '+f+ 'does not seem to be a Debian package ')
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    die('Error: '+f + ' does not exist.')
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    die('Error: '+f+ ' does not seem to be a Debian delta ')
  p.close()

#################################################################### apply patch

def do_patch(delta,olddeb,newdeb,TD):  
  delta=abspath(delta)
  if newdeb:
    newdeb=abspath(newdeb)
  if olddeb != '/':
    olddeb=abspath(olddeb)
    
  start_sec = time.time()
  
  check_diff(delta)

  if INFO:
    os.chdir(TD+'/PATCH')
    system('ar x  '+delta+' patch.sh patch.sh.gz patch.sh.bz2 2> /dev/null')
  else:    
    if olddeb != '/':
      check_deb(olddeb)
    if  newdeb and os.path.exists(newdeb) :
      os.rename(newdeb,newdeb+'~')
    unpack ('PATCH',delta,TD)
  #from here on, we live in the temp dir
  os.chdir(TD)
    
  os.symlink(minigzip,'minigzip')

  if os.path.exists('PATCH/patch.sh.gz'):
    system('gunzip PATCH/patch.sh.gz')
  elif os.path.exists('PATCH/patch.sh.bz2'):
    system('bunzip2 PATCH/patch.sh.bz2')  

  #lets scan parameters, to see what it does and what it requires
  params={}
  if not os.path.isfile('PATCH/patch.sh'):
    die('Error. File '+delta+' is not a debdelta file.')
  p=open('PATCH/patch.sh')
  s=p.readline()#skip #!/bin/sh
  s=p.readline()
  while s :
    if s[0] == '#' :
      s=de_n(s)[1:]
      if VERBOSE or INFO : print ' info: ',s
      if ':' in s:
        i=s.index(':')  
        params[s[:i]] = s[i+2:]
      else:
        params[s] = True
    s=p.readline()
  p.close()

  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      die(' Not enough disk space (%dkB) for applying delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) )

  ## really we will apply the patch
  if not INFO:
    #unpack the old control structure, if available
    os.mkdir(TD+'/OLD/CONTROL')
    if olddeb != '/' :
      os.symlink(olddeb,TD+'/OLD.file')
      #unpack control.tar.gz
      system('ar p OLD.file control.tar.gz | tar -x -z -f - -C OLD/CONTROL')
    #then we check for the conformance
    if  DEBUG:
      dpkg_params={}
      b=params['OLD/Package']
      if olddeb == '/' :
        p=os.popen('env -i dpkg -s '+b)
      else:        
        p=open('OLD/CONTROL/control')
      scan_control(p,dpkg_params,'OLD')
      p.close()
      if  olddeb == '/' :
        if 'OLD/Status' not in dpkg_params:
          die('Error: package %s is not known to dpkg.' % b)
        if  dpkg_params['OLD/Status'] != 'install ok installed' :
          die('Error: package %s is not installed, status is %s.'
            % ( b , dpkg_params['OLD/Status'] ) )
      for a in  params:
        if a[:3] == 'OLD' and a != 'OLD/Installed-Size':
          if a not in dpkg_params:
            die('Error parsing old control file , parameter %s not found' % a)
          elif  params[a] != dpkg_params[a] :
            die( 'Error : in debdelta , '+a+' = ' +params[a] +\
                 '\nin old/installed deb, '+a+' = ' +dpkg_params[a])

    ###see into parameters: the patch may need extra info
    #as a whole unpack of 'ar' of the old deb
    if 'unpack-old' in params:
      if olddeb == '/':
        die('This patch needs the old version Debian package')
      unpack ('OLD',olddeb,TD)

    if 'needs-old' in params and olddeb == '/':
      die('This patch needs the old version Debian package')

    if 'old-data-tree' in params :
      os.mkdir(TD+'/OLD/DATA')
      if olddeb == '/':
        pa=params['OLD/Package']
        s=[]
        p=os.popen('env -i dpkg -L '+pa)
        a=p.readline()
        while a:
          a=de_n(a)
          if s and a[:11] == 'diverted by':
            orig,divert=s.pop()
            #support diversions
            i = a.index(':')
            divert = a[i+2:]
            s.append( (orig,divert) )
          else:
            s.append( (a,a) )
          a=p.readline()
        p.close()        
        for orig,divert in s:          
          if os.path.isfile(divert) and not os.path.islink(divert) :            
            a=make_parents(TD+'/OLD/DATA'+orig)
            if VERBOSE > 3 : print '   symlinking ',divert,' to ',a
            os.symlink(divert, a)
          else:
            if VERBOSE > 4 : print '    not symlinking ',divert,' to ',orig
      else:
        system('ar p OLD.file data.tar.gz | tar -x -z -f - -C OLD/DATA')


    if 'old-control-tree' in params and olddeb == '/':      
      p=params['OLD/Package']
      for  b in dpkg_keeps_controls :
        a='/var/lib/dpkg/info/' + p +'.'+b
        if os.path.exists(a ):
          os.symlink(a,'OLD/CONTROL/'+b)

    ##then , really execute the patch
    a=''
    if VERBOSE > 2 : a = '-v'
    system('/bin/sh -e '+a+' PATCH/patch.sh')
    if newdeb:
      shutil.move('NEW.file',newdeb)

    if VERBOSE > 1:
      if newdeb:
        debsize = os.stat(newdeb)[ST_SIZE]
      else:
        debsize = os.stat(olddeb)[ST_SIZE]
      end_sec = time.time()
      a=(end_sec - start_sec)
      print ' patching time: %dsec, speed:  %dkB per second ' % (a,(debsize / 1024 /  (a+1)))

##################################################### compute delta

def do_delta(olddeb,newdeb,delta,TD):
  start_sec = time.time()

  olddeb=abspath(olddeb)
  check_deb(olddeb)
  os.symlink(olddeb,TD+'/OLD.file')

  newdeb=abspath(newdeb)
  check_deb(newdeb)
  os.symlink(newdeb,TD+'/NEW.file')
  newdebsize = os.stat(newdeb)[ST_SIZE]

  free=freespace(TD)
  if free and free < newdebsize * 2:
    die('Error: not enough disk space in '+TD)

  delta=abspath(delta)
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  #from here on, we live in the temp dir
  os.chdir(TD)

  #counter for numbered files
  global deltacount
  deltacount = 0 

  #start writing script 
  script=open('PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')


  def append(s):
    'appends some data to NEW.file'
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")

  ##### unpack control.tar.gz, scan control, write  parameters
  params={}
  for o in 'OLD', 'NEW' :
      os.mkdir(TD+'/'+o+'/CONTROL')
      #unpack control.tar.gz
      system('ar p '+o+'.file control.tar.gz | tar -x -z -f - -C '+o+'/CONTROL')
      ## scan control
      if  VERBOSE > 1 :
        print o
        s=sys.stdout
      else:
        s=None
      p=open(TD+'/'+o+'/CONTROL/control') 
      scan_control(p,params,o,script,s)
      p.close()
      if s: print
  
  if 'NEW/Installed-Size' in params and 'OLD/Installed-Size' in params:
    free=freespace(TD)  
    instsize=int(params['NEW/Installed-Size']) + int(params['OLD/Installed-Size'])
    if free and free < instsize * 1024  :
      die(' Not enough disk space (%dkB) for creating delta (needs %dkB).' % \
          ( int(free/1024) , instsize ) )

  ## check for conffiles 
  a=TD+'/OLD/CONTROL/conffiles'
  if os.path.exists(a):
    p=open(a)
    old_conffiles=p.read().split('\n')
    p.close()
  else:
    old_conffiles=()
  ############### some routines  to prepare delta of two files

  def patch_append(f):
    os.chdir(TD+'/PATCH')
    system(['ar','qSc', delta,f])
    unlink(f)
    os.chdir(TD)

  def verbatim(f):
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    if VERBOSE > 3 : print '   including "',name,'" verbatim in patch'
    os.rename(f,p)
    patch_append(pp)
    return p
      
  def unzip(f, in_script_as_well = None):
    c=''
    if f[-3:] == '.gz' :
      system('gunzip '+f)
      if in_script_as_well or ( in_script_as_well == None and f[:3] != 'NEW' ):
        script.write('gunzip '+f+'\n')
      f=f[:-3]
      c='.gz'
    elif  f[-3:] == '.bz2' :
      print 'WARNING ! ',f,' is in BZIP2 format ! please fixme !'
    return (f,c)

  def script_zip(n,cn):
    if cn == '.gz' :
      script.write('./minigzip -9 '+n+'\n')
    elif  cn == '.bz2' :
      print 'WARNING ! ',n,' is in BZIP2 format ! please fixme !'
      
  def delta_files(o,n):
    " compute delta of two files , and prepare the script consequently"
    if VERBOSE > 3 : print '   compute delta for  ',o,' and ',n
    nsize = os.stat(n)[ST_SIZE]
    osize = os.stat(o)[ST_SIZE]
    (o,co) = unzip(o)
    (n,cn) = unzip(n)
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    ## bsdiff uses memory equal to 17 times the size of oldfile
    free=freespace(TD)
    if free == None :
      free = MAXMEMORY * 16
    if osize < MAXMEMORY / 17 and osize * 8 < free  :
      system('bsdiff  '+o+' '+n+' '+p)
      script.write('bspatch '+o+' '+n+' '+p+'\n')
    else:
      if VERBOSE > 4 : print '  fallback on xdelta instead of bsdiff' 
      system('xdelta delta -n -9 '+o+' '+n+' '+p)
      script.write('xdelta patch '+p+' '+o+' '+n+'\n')
    ## clean up
    script.write('rm '+p+' '+o+'\n')
    script_zip(n,cn)
    ## how did we fare ?
    deltasize = os.stat(p)[ST_SIZE]
    if VERBOSE > 2 :
      print '  delta is  %3.4f'  % ( deltasize * 100. /  nsize ) , '% of ',n
    #save it
    patch_append(pp)
    #clean up
    unlink(o)
    unlink(n)
    if DEBUG:
      pass #implement MD5

  def delta_tar(o,n,w,skip=()):
    (o,co) = unzip(o,False)
    (n,cn) = unzip(n)
    oldtar = tarfile.open(o, "r")
    oldnames = oldtar.getnames()
    if VERBOSE > 3 : print '   scanning ',n
    newtar = tarfile.open(n, "r")
    for newtarinfo in newtar:
      name = newtarinfo.name
      if  (('/'+name) in  skip ) or ( name in skip ):
        if VERBOSE > 3 : print '   skip using old file ', name
      elif name in oldnames and  newtarinfo.isreg() :
        oldtarinfo = oldtar.getmember(newtarinfo.name)
        if oldtarinfo.isreg() :
          if VERBOSE > 4 : print '  use old file ', name
          oldtar.extract(oldtarinfo.name,"OLD/"+w )
          system('cat OLD/'+w+'/'+name+' >> OLD/mega_cat')
          unlink('OLD/'+w+'/'+name)
          script.write('cat OLD/'+w+'/'+name+'  >> OLD/mega_cat ; rm OLD/'+w+'/'+name+'\n')
      elif VERBOSE > 4 : print '  not diffable from old : ', name

    if os.path.exists('OLD/mega_cat'):
      rmtree('OLD/'+w)
      delta_files('OLD/mega_cat',n)
    else:
      p=verbatim(n)
      script.write('mv '+p+' '+n+ '\n')
    unlink(o)
    script_zip(n,cn)
  ############ start computing deltas

    
  if NEEDSOLD :
    #this delta needs the old deb 
    script.write('#needs-old\n')

  #this following is actually
  #def delta_debs_using_old(old,new):

  ### start scanning the new deb  
  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append(s)

  #process all contents of old vs new .deb
  ar_list_old= list_ar('OLD.file')
  ar_list_new= list_ar('NEW.file')

  for name in ar_list_new :
    n = 'NEW/'+name
    system('ar p NEW.file '+name+' >> '+n)

    newsize = os.stat(n)[ST_SIZE]
    if VERBOSE > 2: print ' studying ' , name , ' of len ' , newsize
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 4: print '  ar line: ',repr(s)
    assert( s[:len(name)] == name and s[-2] == '`' and s[-1] == '\n' )
    append(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(newsize  ,1)
    if newsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if newsize < 128:      #file is too short to compute a delta,
      p=open(n)
      append( p.read(newsize))
      p.close()
      unlink(n)
    elif  name[:11] == 'control.tar' :
      #(mm this is almost useless, just saves a few bytes)
      script.write('#old-control-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      ##avoid using strange files that dpkg may not install in /var...info/
      skip=[]
      for a in os.listdir('OLD/CONTROL') :
        if a not in dpkg_keeps_controls:
          skip.append(a)
      #delta it
      delta_tar(o,n,'CONTROL',skip)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif not NEEDSOLD and name[:8] == 'data.tar'  :
      script.write('#old-data-tree\n')
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      delta_tar(o,n,'DATA',old_conffiles)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    elif  not NEEDSOLD  or name not in ar_list_old :   #or it is not in old deb
      p=verbatim(n)
      script.write('cat '+p+' >> NEW.file ; rm '+p+'\n')
    elif  NEEDSOLD :
      #file is long, and has old version ; lets compute a delta
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      script.write('ar p OLD.file '+name+' >> '+o+'\n')
      delta_files(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    else:
      die('internal error')
    #pad new deb
    if extrachar :
      append(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if s:
    if VERBOSE > 2: print '  ar leftover character: ',repr(s)
    append(s)

  if DEBUG:
    # add a MD5 check to script
    p=os.popen('md5sum NEW.file')
    a=p.readline()
    p.read()
    p.close
    a=de_n(a)
    if VERBOSE > 2 : print '   ',a
    script.write('echo "'+a+'" | md5sum -c > /dev/null')

  #script is done
  script.close()
  patchsize = os.stat('PATCH/patch.sh')[ST_SIZE]
  if  patchsize > newdebsize / 5 and patchsize > 512 :
    if VERBOSE > 2 : print '  patch.sh is quite large: using bzip2 '
    system('bzip2 -9  PATCH/patch.sh')
    patch_append('patch.sh.bz2')
  else:
    system('gzip -9 -n PATCH/patch.sh')  
    patch_append('patch.sh.gz')

  deltasize = os.stat(delta)[ST_SIZE]
  
  elaps =  time.time() - start_sec
  percent =  deltasize * 100. /  newdebsize 
  if VERBOSE:
    print ' deb delta is  %3.1f%% of deb ; that is, %dkB would be saved' \
          % ( percent , (( newdebsize -deltasize ) / 1024) )
    if VERBOSE > 1:
      print '  delta time: %dsec, speed: %dkB per second ' %  \
            (elaps, newdebsize / 1024 / (elaps+1))
  return (delta, percent, elaps)


##################################################### compute many deltas

def do_deltas(argv):
  original_cwd = os.getcwd()
  try:
    from apt import VersionCompare
  except ImportError:
    import apt_pkg
    apt_pkg.InitSystem()
    from apt_pkg import VersionCompare
  debs=[]
  for i in argv:
    debs.append(i)

  info_by_pack_arch={}
  info_by_file={}

  def scan_deb(f):
      info_by_file[f]={}
      p=os.popen('ar p '+f+' control.tar.gz | tar -x -z -f - -O ./control')
      scan_control(p,info_by_file[f])
      p.close()
      info_by_file[f]['File'] = f
      pa=info_by_file[f]['Package']
      ar=info_by_file[f]['Architecture']
      if  (pa,ar) not in  info_by_pack_arch :
         info_by_pack_arch[ (pa,ar) ]=[]
      info_by_pack_arch[ (pa,ar) ].append( info_by_file[f] )

  for f in debs:
    if os.path.isfile(f):
      scan_deb(f)
    elif  os.path.isdir(f) :
      for a in  filter( lambda a : a[-4:] == '.deb' ,os.listdir(f) ) :
        scan_deb(f+'/'+a)
    else:
      print 'Warning: '+f+' is not a regular file or a directory.'
      
  def order_by_version(a,b):
    return VersionCompare( a['Version'] , b['Version']  )
  
  for pa,ar in info_by_pack_arch :
    l= len( info_by_pack_arch[ (pa,ar) ] )

    if l > 1 :
      info_by_pack_arch[ (pa,ar) ].sort(order_by_version)

      l -= 1
      while l>0:
        os.chdir(original_cwd)
        l -= 1
        old=info_by_pack_arch[ (pa,ar) ][l]
        new=info_by_pack_arch[ (pa,ar) ][l+1]

        newdebsize=os.stat(new['File'])[ST_SIZE]
        if newdebsize <= 20 * 1024 :
          if VERBOSE :     print 'Skip , too small: ', new['File']
          break
        
        assert( old['Package'] == pa and pa == new['Package'] )
        deltabasename = pa +'_'+  old['Version'] +'_'+ new['Version'] +'_'+ar+'.debdelta'
        if DIR:
          if DIR[-2:] == '//' :
            a=DIR+'/'+os.path.dirname(new['File'])+'/'+deltabasename
            delta=make_parents(a)
          else:
            delta = DIR+'/'+deltabasename
        else:
          delta = os.path.dirname(new['File']) + '/'+deltabasename
        if os.path.exists(delta):
          if VERBOSE > 2:     print 'Skip , already exists: ',delta
          break
        if os.path.exists(delta+'-too-big'):
          if VERBOSE > 2:     print 'Skip , tried and too big: ',delta
          break

        free=freespace(os.path.dirname(delta))
        if free and free < newdebsize /2 + 1024 :
          if VERBOSE : print ' Not enough disk space for',delta
          break
        
        if VERBOSE: print 'Creating :',delta
        ret= None
        T=tempo()          
        try:
          ret=do_delta(old['File'],new['File'], delta,T)
        except KeyboardInterrupt:
          raise
        except DebDeltaError:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          print ' Creation of ',delta,' failed.'
        except:
          os.chdir(original_cwd)
          if os.path.exists(delta):
            os.unlink(delta)
          raise
        os.chdir(original_cwd)
        rmtree(T)

        if ret and MAX_DELTA_PERCENT:
          if ret[1] > MAX_DELTA_PERCENT:
            os.unlink(delta)
            if VERBOSE : print ' Error, too big:',delta
            p=open(delta+'-too-big','w')
            p.close()
            ret = None

        if DEBUG > 1 and ret :
          T=tempo()
          try:
            do_patch(delta,old['File'],None ,T)
          except KeyboardInterrupt:
            raise
          except DebDeltaError:
            print ' Error: testing of delta failed: ',delta
            os.chdir(original_cwd)
            if os.path.exists(delta):
              os.unlink(delta)
          except:
            os.chdir(original_cwd)
            print " Unexpected error while testing delta:", sys.exc_info()[0]
            os.unlink(delta)
            raise
          os.chdir(original_cwd)
          rmtree(T)

################################################# main program, do stuff

if action == 'patch':
  newdeb=abspath(argv[2])
  T=tempo()
  try:
    do_patch(abspath(argv[0]), abspath(argv[1]), newdeb ,T)
  except DebDeltaError:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    rmtree(T)
    sys.exit(2)
  except:
    if os.path.exists(newdeb):
      os.unlink(newdeb)
    raise
  rmtree(T)
  
elif action == 'delta' :  
  T=tempo()
  delta=abspath(argv[2])
  try:
    do_delta(abspath(argv[0]), abspath(argv[1]), delta ,T)  
  except DebDeltaError:
    rmtree(T)
    if os.path.exists(delta):
      os.unlink(delta)
    sys.exit(2)
  except:
    if os.path.exists(delta):
      os.unlink(delta)
    raise
  rmtree(T)
  
elif action == 'deltas' :
  try:
    do_deltas(argv)
  except DebDeltaError:
    sys.exit(2)


    

