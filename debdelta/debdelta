#!/usr/bin/python

"""\
Usage: debdelta [ option...  ] fromfile tofile patchout
  Computes a delta from fromfile to tofile and writes it to patchout

Usage: debpatch [ option...  ] patchin  fromfile  tofile 
  Applies patchin to fromfile and produces  a  reconstructed  version of tofile.

Usage: debpatch --info  patch
  Write info on patch.

Options for debdelta:
  --fs    create a (larger) patch that can be used to recreate the new .deb
          from the old deb that is installed in the host.
          In this case, when using 'debpatch', use '/' for fromfile.
  -d      debug : add md5sums to patch
 --noinfo do not insert in patch the info on two Debian files
  -M Mb   maximum memory (decides between using 'bsdiff' or 'xdelta')
Options for debpatch:
 --info  print info on two Debian files, and exists
Options for both:
  -v      verbose (can be added multiple times
  -k      keep temporary files
"""

minigzip='/usr/lib/debdelta/minigzip'


####################################################################

import sys , os , tempfile , string ,getopt

from stat    import ST_SIZE
from os.path import abspath
from os      import unlink, rmdir

####################################################################

action=(os.path.basename(sys.argv[0]))[3:]
actions =  ('delta','patch')
if action not in actions:
  print 'wrong filename: should be "deb" + '+repr(actions)
  sys.exit(0)

( opts, argv ) = getopt.getopt(sys.argv[1:], 'vkhdM:' ,
                               ('help','info','fs') )

cwd = os.getcwd()

MAXMEMORY = 1024 * 1024 * 50
DEBUG   = 0
VERBOSE = 0
KEEP    = False
INFO    = action == 'delta'
FS      = False

for  o , v  in  opts :
  if o == '-v' : VERBOSE += 1
  elif o == '-d' and action == 'delta' : DEBUG += 1
  elif o == '-k' : KEEP = True
  elif o == '--fs' and action == 'delta' : FS = True
  elif o == '-M' and action == 'delta' :    MAXMEMORY = 1024 * 1024 * int(v)
  elif o == '--info' : INFO = True
  elif o == '--noinfo' : INFO = False 
  elif o ==  '--help' or o ==  '-h':
    print __doc__
    sys.exit(0)
  else:
    print ' option ',o,'is unknown, try --help'
    sys.exit(1)

if INFO and action == 'patch' :
  if  len(argv) > 1 and VERBOSE :
    print '(printing info - extra arguments are ignored)'
  elif  len(argv) == 0  :
    print ' need a  filename ;  try --help'
    sys.exit(1)
elif len(argv) != 3  or ( len(argv) != 3   ):  
  print ' need 3 filenames ;  try --help'
  sys.exit(1)

######################################################################
def system(a):
  if type(a) != type('') :
    a=string.join(a,' ')
  ret = os.system(a)
  if  ret != 0 and ( ret != 256 or a[:6] != 'xdelta') :
    print ' error , non zero return status ',ret,' for ',a
    sys.exit(2)

def check_deb(f):
  if not  os.path.isfile(f) :
    print f , ' does not exists '
  p=open(f)
  if p.read(21) != "!<arch>\ndebian-binary" :
    print f , ' does not seem to be a Debian package '
    sys.exit(1)
  p.close()

def check_diff(f):
  if not  os.path.isfile(f) :
    print f , ' does not exists '
  p=open(f)
  if p.read(8) != "!<arch>\n" :
    print f , ' does not seem to be a Debian delta '
    sys.exit(1)
  p.close()

def de_n(a):
  if a[-1] ==  '\n' :
    a = a[:-1]
  return a


def list_ar(f):
  assert(os.path.exists(f))
  ar_list = []
  p=os.popen('ar t '+f,'r')
  while 1:
    a=p.readline()
    if not a : break
    a=de_n(a)
    ar_list.append(a)    
  p.close()
  return ar_list


def unpack(d,f):
  "unpacks 'ar' file f in directory d"
  assert(os.path.exists(f))
  cwd = os.getcwd()
  os.chdir(TD+'/'+d)
  system('ar xo '+f)
  os.chdir(cwd)


ALLOWED = '<>()[]{}.,;:!_-+/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

def prepare_for_echo(s):
  r=''
  while s:
    a=s[0]
    s=s[1:]
    if a in ALLOWED :
      r += a
    else:
      r += "\\" + ( '0000' +oct(ord(a)))[-4:]
  return r

####################################################################
if KEEP:
  def unlink(a):
    if VERBOSE : print ' would unlink ',a
  def rmdir(a):
    if VERBOSE : print ' would rmdir ',a


TD = abspath(tempfile.mkdtemp())
for i in 'OLD','NEW','PATCH' :
  os.mkdir(TD+'/'+i)
if DEBUG or VERBOSE > 1 :  print 'temporary in '+TD


  
#################################################################### apply patch

if action == 'patch':  
  delta = abspath(argv[0])
  check_diff(delta)

  if INFO:
    os.chdir(TD+'/PATCH')
    system('ar x  '+delta+' patch.sh patch.sh.gz patch.sh.bz2 2> /dev/null')
  else:
    newdeb = abspath(argv[2])
    if  os.path.exists(newdeb) :
      os.rename(newdeb,newdeb+'~')
    
    olddeb = abspath(argv[1])
    if olddeb != '/':
      check_deb(olddeb)
    
    unpack ('PATCH',delta)
  #from here on, we live in the temp dir
  os.chdir(TD)
    
  os.symlink(minigzip,'minigzip')

  if os.path.exists('PATCH/patch.sh.gz'):
    system('gunzip PATCH/patch.sh.gz')
  elif os.path.exists('PATCH/patch.sh.bz2'):
    system('bunzip2 PATCH/patch.sh.bz2')  

  #lets see what it does and what it requires
  params={}
  p=open('PATCH/patch.sh')
  s=p.readline()#skip #!/bin/sh
  s=p.readline()
  while s and s[0] == '#':
    s=de_n(s)[1:]
    if VERBOSE or INFO : print ' info: ',s
    if ':' in s:
      i=s.index(':')  
      params[s[:i]] = s[i+1:]
    else:
      params[s] = True
    s=p.readline()
  p.close()


  if not INFO:
    if 'unpack-old' in params:
      if olddeb == '/':
        raise 'needs old version Debian package'
      unpack ('OLD',olddeb)
      os.symlink(olddeb,TD+'/OLD.file')
    
    if 'needs-old' in params:
      if olddeb == '/':
        raise 'needs old version Debian package'
      os.symlink(olddeb,TD+'/OLD.file')

    a=''
    if VERBOSE > 2 : a = '-v'
    system('/bin/sh -e '+a+' PATCH/patch.sh')

    os.rename('NEW.file',newdeb)

  for o in  'PATCH/patch.sh','PATCH.file','minigzip','OLD.file':
    if os.path.exists(o):
      if VERBOSE > 5 : print ' deleting ',o
      unlink(o)
  for o in os.listdir('OLD'):
    if VERBOSE > 5 : print ' deleting OLD/',o
    unlink('OLD/'+o)

##################################################### compute delta
elif action == 'delta' :
  olddeb = abspath(argv[0])
  check_deb(olddeb)
  os.symlink(olddeb,TD+'/OLD.file')
  
  newdeb = abspath(argv[1])
  check_deb(newdeb)
  os.symlink(newdeb,TD+'/NEW.file')
  newdebsize = os.stat(newdeb)[ST_SIZE]
  
  delta = abspath(argv[2])
  if  os.path.exists(delta) :
    os.rename(delta,delta+'~')
  
  #from here on, we live in the temp dir
  os.chdir(TD)

  #counter for numbered files
  global deltacount
  deltacount = 0 

  #start writing script 
  script=open('PATCH/patch.sh','w')
  script.write('#!/bin/sh -e\n')

  ##### write parameters
  if DEBUG or INFO:
    for o in 'OLD', 'NEW' :
      if INFO : print o
      system('ar p  '+o+'.file control.tar.gz | tar xzf - ./control')
      p=open('control')
      a=p.readline()
      while a:
        a=de_n(a)
        if a[:3] in ('Pac','Ver','Arc'):
          if DEBUG : script.write('#'+o+'/'+a+'\n')
          if INFO : print ' ' , a
        a=p.readline()
      p.close()
    unlink('control')

  def append(s):
    s=prepare_for_echo(s)
    script.write("echo -n -e '"+ s +"' >> NEW.file\n")


  #this delta needs the old deb , unpacked in 'OLD'
  #script.write('#unpack-old\n')
  #this delta needs the old deb 
  script.write('#needs-old\n')

  ############### some routines  to prepare delta of two files

  def patch_append(f):
    os.chdir(TD+'/PATCH')
    system(['ar','qSc', delta,f])
    unlink(f)
    os.chdir(TD)
    
  def unzip(f):
    c=''
    if f[-3:] == '.gz' :
      system('gunzip '+f)
      if f[:3] != 'NEW' :
        script.write('gunzip '+f+'\n')
      f=f[:-3]
      c='.gz'
    elif  f[-3:] == '.bz2' :
      print 'WARNING ! ',f,' is in BZIP2 format ! please fixme !'
    return (f,c)

  def script_zip(n,cn):
    if cn == '.gz' :
      script.write('minigzip -9 '+n+'\n')
    elif  cn == '.bz2' :
      print 'WARNING ! ',n,' is in BZIP2 format ! please fixme !'
      
  def delta_files(o,n):
    " compute delta of two files , and prepare the script consequently"
    if VERBOSE > 3 : print '   compute delta for  ',o,' and ',n
    nsize = os.stat(n)[ST_SIZE]
    osize = os.stat(o)[ST_SIZE]
    (o,co) = unzip(o)
    (n,cn) = unzip(n)
    global deltacount
    deltacount += 1
    pp=str(deltacount)
    p = 'PATCH/'+pp
    ## bsdiff uses memory equal to 17 times the size of oldfile
    try:
      a=os.statvfs(TD)
      freespace= a[0] * a[4]
    except a:
      if VERBOSE : print ' statvfs error ',a
      freespace = MAXMEMORY * 16
    if osize < MAXMEMORY / 17 and osize * 8 < freespace   :
      system('bsdiff  '+o+' '+n+' '+p)
      script.write('bspatch '+o+' '+n+' '+p+'\n')
    else:
      if VERBOSE > 2 : print '  fallback on xdelta instead of bsdiff' 
      system('xdelta delta -n -9 '+o+' '+n+' '+p)
      script.write('xdelta patch '+p+' '+o+' '+n+'\n')
    ## clean up
    script.write('rm '+p+' '+o+'\n')
    script_zip(n,cn)
    ## how did we fare ?
    deltasize = os.stat(p)[ST_SIZE]
    if VERBOSE > 1 :
      print '  delta is  %3.4f'  % ( deltasize * 100. /  nsize ) , '% of ',n

    #save it
    patch_append(pp)
    #clean up
    unlink(o)
    unlink(n)
    if DEBUG:
      pass #implement MD5

  ############# start scanning the new deb
  #this following is actually
  #def delta_debs_using_old(old,new):

  newdeb_file=open(newdeb)
  # pop the "!<arch>\n"
  s = newdeb_file.readline()
  assert( "!<arch>\n" == s)
  append(s)

  #process all contents of old vs new .deb

  ar_list_old= list_ar('OLD.file')
  ar_list_new= list_ar('NEW.file')

  for name in ar_list_new :
    n = 'NEW/'+name
    system('ar p NEW.file '+name+' >> '+n)

    newsize = os.stat(n)[ST_SIZE]
    if VERBOSE > 1: print ' studying ' , name , ' of len ' , newsize
    #add 'ar' structure
    s = newdeb_file.read(60)
    if VERBOSE > 2: print '  ar line: ',repr(s)
    assert( s[:len(name)] == name and s[-2] == '`' and s[-1] == '\n' )
    append(s)
    #sometimes there is an extra \n, depending if the previous was odd length
    newdeb_file.seek(newsize  ,1)
    if newsize & 1 :
      extrachar = newdeb_file.read(1)
    else:
      extrachar = ''
    #add file to debdelta
    if newsize < 128:      #file is too short to compute a delta,
      p=open(n)
      append( p.read(newsize))
      p.close()
      unlink(n)
    elif  name not in ar_list_old :       #or it is not in old deb
      deltacount += 1
      p = 'PATCH/'+str(deltacount)
      os.rename(n,p)
      patch_append(p)
      script.write('echo PATCH/'+o+' >> NEW.file')
      if DEBUG: script.write('rm PATCH/'+o+'\n')
    else:
      #file is long, and has old version ; lets compute a delta
      o = 'OLD/'+name
      system('ar p OLD.file '+name+' >> '+o)
      script.write('ar p OLD.file '+name+' >> '+o+'\n')
      delta_files(o,n)
      script.write('cat '+n+' >> NEW.file ;  rm '+n+'\n')
    #pad new deb
    if extrachar :
      append(extrachar)
  # put in script any leftover
  s = newdeb_file.read()
  if s:
    if VERBOSE > 2: print '  ar leftover character: ',repr(s)
    append(s)

  if DEBUG:
    # add a MD5 check to script
    p=os.popen('md5sum NEW.file')
    a=p.readline()
    p.read()
    p.close
    a=de_n(a)
    if VERBOSE > 2 : print '   ',a
    script.write('echo "'+a+'" | md5sum -c > /dev/null')

  #script is done
  script.close()  
  system('gzip -9 -n PATCH/patch.sh')
  
  patch_append('patch.sh.gz')
    
  deltasize = os.stat(delta)[ST_SIZE]
  unlink('NEW.file')
  unlink('OLD.file')

  if VERBOSE:
    print ' deb delta is  %3.1f'  % \
          ( deltasize * 100. /  newdebsize ) ,    '% of deb'
    print ' that is, %dkB would be saved ' % (( newdebsize -deltasize  ) / 1024)
####################################
else:
  #unimplemented action
  assert(0)

#cleanup
os.chdir(TD)
rmdir('PATCH')
rmdir('OLD')
rmdir('NEW')
rmdir(TD)


##   a='ar qSc result.deb '
##   for o in arlist['NEW'] :
##     a=a+ ' ' + o + ' '

##     '!<arch>\n'

##   a='fakeroot sh -c "chown root.root * ; ' + a + ' " '
  
##   s.write()
  
##   S(' cd NEW ; ' + a)

##   ret=os.system('cmp NEW/result.deb '+newdeb )

##   if ret:
##     S('xdelta delta -n -9 '+newdeb+' NEW/result.deb ')
##   #S(['ar','qSc', 'temp.deb',]+ deltaparts)
##   #s.write('xdelta patch '+o+'.xdelta'+' ../OLD/'+o+' '+o+'\n')
  
##   def a(p,k,v):
##     if  p == None:
##       p = {}
##     if len(k) > 1  :
##       p[k[0]] = a(p.get(k[0]) , k[1:] ,v  )
##     else:
##       p[k[0]] = v
##       return p    

##     if '/' in s:
##       s=s.split('/')
##       if (len (s) == 2) :
##         ( a,  v ) = s
##         if '/' in s:
##           ....
##         params[ a  ] = v

##       elif (len (s) == 3) :
##         ( a, b, v ) = s
##         if a not in params :
##           params[a] ={}
##         params[ a ][b] = v
##       else:
##         print 'internal error on parm ', repr(s)
